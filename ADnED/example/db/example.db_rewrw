
#####################################################################
#
# areaDetector nED client template file. This is the top level
# template file that may include other files or override default
# areaDetector records.
#
# Matt Pearson
# Sept 14
#
# Macros:
# P - base PV name
# ADNED - middle part of PV name (eg: BL99:Det:N1:Det1:TOF:Array)
# PORT - Asyn port name
# ADDR - Asyn address (set to zero)
# TIMEOUT - Asyn timeout
# TOFSIZE - The maximum size of the TOF spectrum (eg. 160000)
# TOF1SIZE - The size of the waveform for the DET1 TOF spectrum
# TOF2SIZE - The size of the waveform for the DET2 TOF spectrum
# TOF3SIZE - The size of the waveform for the DET3 TOF spectrum
# TOF4SIZE - The size of the waveform for the DET4 TOF spectrum
# DET1SIZE - The size of the DET1 waveform
# DET2SIZE - The size of the DET2 waveform
# DET3SIZE - The size of the DET3 waveform
# DET4SIZE - The size of the DET4 waveform
# DET1X - The X size of the DET1 XY plot
# DET2X - The X size of the DET2 XY plot
# DET3X - The X size of the DET3 XY plot
# DET4X - The X size of the DET4 XY plot
# DET1Y - The Y size of the DET1 XY plot
# DET2Y - The Y size of the DET2 XY plot
# DET3Y - The Y size of the DET3 XY plot
# DET4Y - The Y size of the DET4 XY plot
#
#####################################################################


#=================================================================#
# Template file: ADBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1,0,5)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1,0,5)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1,0,5)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Dim0SA")
    field(FLNK, "BL99:Det:N1:Dim1SA")
}

record(subArray, "BL99:Det:N1:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Dim1SA")
    field(FLNK, "BL99:Det:N1:Dim2SA")
}

record(subArray, "BL99:Det:N1:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Dim3SA")
}

record(mbbi, "BL99:Det:N1:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1,0,5)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,0,5)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,0,5)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,0,5)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  These records control basic information                        #
#  about the detector                                             # 
###################################################################

record(stringin, "BL99:Det:N1:Manufacturer_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1,0,5)MANUFACTURER")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(stringin, "BL99:Det:N1:Model_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1,0,5)MODEL")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)MAX_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)MAX_SIZE_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the detector readout                     #
#  including binning, region start and size                       # 
###################################################################

record(longout, "BL99:Det:N1:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)BIN_X")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)BIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)BIN_Y")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)BIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)MIN_X")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)MIN_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)MIN_Y")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)SIZE_X")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)SIZE_Y")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)REVERSE_X")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)REVERSE_Y")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the acquisition time and                 #
#  period                                                         # 
###################################################################
record(ao, "BL99:Det:N1:AcquireTime")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)ACQ_TIME")
   field(PREC, "3")
   field(VAL,  "1.0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:AcquireTime_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ACQ_TIME")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:AcquirePeriod")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)ACQ_PERIOD")
   field(PREC, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:AcquirePeriod_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ACQ_PERIOD")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:TimeRemaining_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)TIME_REMAINING")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the gain                                 # 
###################################################################
record(ao, "BL99:Det:N1:Gain")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)GAIN")
   field(VAL,  "1.0")
   field(PREC, "3")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Gain_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)GAIN")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the frame type                           # 
###################################################################
record(mbbo, "BL99:Det:N1:FrameType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:FrameType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)FRAME_TYPE")
   field(ZRST, "Normal")
   field(ZRVL, "0")
   field(ONST, "Background")
   field(ONVL, "1")
   field(TWST, "FlatField")
   field(TWVL, "2")
   field(THST, "DblCorrelation")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the acquisition mode                     # 
###################################################################
record(mbbo, "BL99:Det:N1:ImageMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(VAL,  "2")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:ImageMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)IMAGE_MODE")
   field(ZRST, "Single")
   field(ZRVL, "0")
   field(ONST, "Multiple")
   field(ONVL, "1")
   field(TWST, "Continuous")
   field(TWVL, "2")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the trigger mode                         # 
###################################################################
record(mbbo, "BL99:Det:N1:TriggerMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:TriggerMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)TRIGGER_MODE")
   field(ZRST, "Internal")
   field(ZRVL, "0")
   field(ONST, "External")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the number of exposures and              #
#  number of images                                               # 
###################################################################
record(longout, "BL99:Det:N1:NumExposures")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)NEXPOSURES")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:NumExposures_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)NEXPOSURES")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:NumExposuresCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)NEXPOSURES_COUNTER")
   field(SCAN, "I/O Intr")
}
record(longout, "BL99:Det:N1:NumImages")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)NIMAGES")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:NumImages_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)NIMAGES")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:NumImagesCounter_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)NIMAGES_COUNTER")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control  acquisition start and                   # 
#  and stop                                                       #
###################################################################

record(busy, "BL99:Det:N1:Acquire") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(N1,0,5)ACQUIRE")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
}

record(bi, "BL99:Det:N1:Acquire_RBV") {
   field(DTYP, "asynInt32")
   field(INP, "@asyn(N1,0,5)ACQUIRE")
   field(ZNAM, "Done")
   field(ZSV,  "NO_ALARM")
   field(ONAM, "Acquiring")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are for the detector state                       # 
###################################################################

record(mbbi, "BL99:Det:N1:DetectorState_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)STATUS")
    field(ZRST, "Idle")
    field(ZRVL, "0")
    field(ZRSV, "NO_ALARM")
    field(ONST, "Acquire")
    field(ONVL, "1")
    field(ONSV, "NO_ALARM")
    field(TWST, "Readout")
    field(TWVL, "2")
    field(TWSV, "NO_ALARM")
    field(THST, "Correct")
    field(THVL, "3")
    field(THSV, "NO_ALARM")
    field(FRST, "Saving")
    field(FRVL, "4")
    field(FRSV, "NO_ALARM")
    field(FVST, "Aborting")
    field(FVVL, "5")
    field(FVSV, "MINOR")
    field(SXST, "Error")
    field(SXVL, "6")
    field(SXSV, "MAJOR")
    field(SVST, "Waiting")
    field(SVVL, "7")
    field(SVSV, "NO_ALARM")
    field(EIST, "Initializing")
    field(EIVL, "8")
    field(EISV, "NO_ALARM")
    field(NIST, "Disconnected")
    field(NIVL, "9")
    field(NISV, "INVALID")
    field(TEST, "Aborted")
    field(TEVL, "10")
    field(TESV, "MINOR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide status information                       # 
###################################################################

# Status message.
record(waveform, "BL99:Det:N1:StatusMessage_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,0,5)STATUS_MESSAGE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:StringToServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,0,5)STRING_TO_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:StringFromServer_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,0,5)STRING_FROM_SERVER")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

################################################################@###
#  This record can be used to force a read of the detector status  # 
####################################################################
record(bo,"BL99:Det:N1:ReadStatus") {
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(N1,0,5)READ_STATUS")
    field(VAL, "1")
    field(SCAN,"Passive")
    info(autosaveFields, "SCAN")
}

###################################################################
#  These records control the shutter                              # 
###################################################################

record(mbbo, "BL99:Det:N1:ShutterMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,0,5)SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Detector output")
    field(TWVL, "2")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:ShutterMode_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)SHUTTER_MODE")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "EPICS PV")
    field(ONVL, "1")
    field(TWST, "Camera output")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:ShutterControl")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,0,5)SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(VAL,  "0")
}

record(bi, "BL99:Det:N1:ShutterControl_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)SHUTTER_CONTROL")
    field(ZNAM, "Close")
    field(ONAM, "Open")
    field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:ShutterStatus_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)SHUTTER_STATUS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:ShutterOpenDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:ShutterOpenDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)SHUTTER_OPEN_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:ShutterCloseDelay")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(VAL,  "0.0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:ShutterCloseDelay_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)SHUTTER_CLOSE_DELAY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

# This record changes state when the driver opens/closes an EPICS shutter
record(bi, "BL99:Det:N1:ShutterControlEPICS")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,0,5)SHUTTER_CONTROL_EPICS")
    field(ZNAM, "Closed")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Open")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
    field(FLNK, "BL99:Det:N1:ShutterFanout.PROC")
}

record(fanout, "BL99:Det:N1:ShutterFanout")
{
    field(LNK1, "BL99:Det:N1:ShutterOpenEPICS.PROC PP MS")
    field(LNK2, "BL99:Det:N1:ShutterCloseEPICS.PROC PP MS")
}

record(calcout, "BL99:Det:N1:ShutterOpenEPICS")
{
    field(INPA, "BL99:Det:N1:ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Non-zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "1")
    field(OUT,  "")
    info(autosaveFields, "OUT OCAL")
}

record(calcout, "BL99:Det:N1:ShutterCloseEPICS")
{
    field(INPA, "BL99:Det:N1:ShutterControlEPICS.VAL NPP NMS")
    field(CALC, "A")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
    field(OCAL, "0")
    field(OUT,  "")
    info(autosaveFields, "OUT OCAL")
}

record(mbbi, "BL99:Det:N1:ShutterStatusEPICS_RBV")
{
    field(DTYP, "Raw Soft Channel")
    field(INP,  "test CP MS")
    field(ZRVL, "0")
    field(ZRST, "Closed")
    field(ZRSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "Open")
    field(ONSV, "MINOR")
    info(autosaveFields, "INP ZRVL ONVL")
}

###################################################################
#  These records control the detector temperature                 # 
###################################################################
 
record(ao, "BL99:Det:N1:Temperature")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)TEMPERATURE")
   field(PREC, "1")
   field(EGU,  "C")
   field(VAL,  "25.0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Temperature_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)TEMPERATURE")
   field(PREC, "1")
   field(EGU,  "C")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:TemperatureActual")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)TEMPERATURE_ACTUAL")
   field(PREC, "1")
   field(EGU,  "C")
   field(SCAN, "I/O Intr")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:AsynIO")
{
    field(PORT, N1)
    field(TIB2,"1")
    info("ADType", "ADDriver")
}


# /// 
# /// Reset the counts without starting. This clears the same parameters
# /// as we do on a start. It also resets the ROI plugins.
# ///
record(bo, "BL99:Det:N1:Reset")
{
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(N1,0,5)ADNED_RESET")
    field(ZNAM,"Done")  
    field(ONAM,"Reset")
    field(FLNK, "BL99:Det:N1:ResetPlugins")
}

# /// 
# /// Events debug (prints to stdout).
# ///
record(bo, "BL99:Det:N1:EventDebug")
{
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(N1,0,5)ADNED_EVENT_DEBUG")
    field(ZNAM,"Off")  
    field(ONAM,"On")
}

# ///
# /// Number of pulses detected by comparing seq timestamps from the first channel.
# ///
record(longin, "BL99:Det:N1:PulseCounter_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_PULSE_COUNTER")
   field(SCAN, "I/O Intr")
}
record(calc, "BL99:Det:N1:PulseRate_RBV")
{
    field(INPA, "BL99:Det:N1:PulseRate_RBV.B NPP NMS") 
    field(INPB, "BL99:Det:N1:PulseCounter_RBV NPP NMS")
    field(INPC, "1.0")                         
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
    field(EGU, "Hz")
}

# ///
# /// Event rate
# ///
record(longin, "BL99:Det:N1:EventRate_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_EVENT_RATE")
   field(SCAN, "I/O Intr")
   field(EGU, "e/s")
}


# ///
# /// This will be non-zero if any missing V4 packets are detected. This record
# /// will be updated with the latest missing sequence ID.
# ///
record(longin, "BL99:Det:N1:SeqIDMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_ID_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is the number of missing V4 packets, if any have been detected.
# ///
record(longin, "BL99:Det:N1:SeqIDNumMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_ID_NUM_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is a flag to indicate I detected an out of order packet (with backwards timestamp).
# ///
record(bi, "BL99:Det:N1:BadTimeStamp_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_BAD_TIMESTAMP")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(ZSV, "NO_ALARM")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// Time between updates (ms) from the event thread.
# ///
record(ao, "BL99:Det:N1:EventUpdatePeriod")
{
   field(DESC, "Event Update Period")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)ADNED_EVENT_UPDATE_PERIOD")
   field(PREC, "0")
   field(VAL, "100")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Time between updates (ms) from the event thread (readback).
# ///
record(ai, "BL99:Det:N1:EventUpdatePeriod_RBV")
{
   field(DESC, "Event Update Period")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ADNED_EVENT_UPDATE_PERIOD")
   field(PREC, "0")
   field(SCAN, "I/O Intr")
   field(EGU, "ms")	
}

# ///
# /// Number of PVAccess channels. This cannot exceed a maximum number
# /// hardcoded in the driver (which is 4, 0-3).
# ///
record(longout, "BL99:Det:N1:NumChannels")
{
   field(DESC, "Num Channels")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)ADNED_NUM_CHANNELS")
   field(VAL, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Number of PVAccess channels (readback)
# ///
record(longin, "BL99:Det:N1:NumChannels_RBV")
{
   field(DESC, "Num Channels")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_NUM_CHANNELS")
   field(SCAN, "I/O Intr")
}

# ///
# /// Time between NDArray updates (ms) from the frame thread.
# ///
record(ao, "BL99:Det:N1:FrameUpdatePeriod")
{
   field(DESC, "Frame Update Period")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,0,5)ADNED_FRAME_UPDATE_PERIOD")
   field(PREC, "0")
   field(VAL, "100")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Time between NDArray updates (ms) from the frame thread (readback).
# ///
record(ai, "BL99:Det:N1:FrameUpdatePeriod_RBV")
{
   field(DESC, "Frame Update Period")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ADNED_FRAME_UPDATE_PERIOD")
   field(PREC, "0")
   field(SCAN, "I/O Intr")
   field(EGU, "ms")	
}

# ///
# /// Number of detectors. This cannot exceed a maximum number
# /// hardcoded in the driver.
# ///
record(longout, "BL99:Det:N1:NumDetectors")
{
   field(DESC, "Num Detectors")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)ADNED_NUM_DET")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Number of detectors (readback)
# ///
record(longin, "BL99:Det:N1:NumDetectors_RBV")
{
   field(DESC, "Num Detectors")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_NUM_DET")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Max (eg. 160000 or 320000, in units of 100ns).
# ///
record(longout, "BL99:Det:N1:TOFMax")
{
   field(DESC, "Max TOF Value")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,0,5)ADNED_TOF_MAX")
   field(VAL, "160000")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// TOF Max (eg. 160000 or 320000, in units of 100ns). (readback)
# ///
record(longin, "BL99:Det:N1:TOFMax_RBV")
{
   field(DESC, "Max TOF Value")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_TOF_MAX")
   field(SCAN, "I/O Intr")
}

# ///
# /// The latest RTDL proton charge
# ///
record(ai, "BL99:Det:N1:PCharge_RBV")
{
   field(DESC, "Latest Proton Charge")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ADNED_PCHARGE")
   field(PREC, "4")
   field(SCAN, "I/O Intr")
   field(EGU, "C")	
}

# ///
# /// The integrated RTDL proton charge
# ///
record(ai, "BL99:Det:N1:PChargeIntegrated_RBV")
{
   field(DESC, "Integrated Proton Charge")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,0,5)ADNED_PCHARGE_INT")
   field(PREC, "4")
   field(SCAN, "I/O Intr")
   field(EGU, "C")
   field(FLNK, "BL99:Det:N1:PChargeIntegrated_pC")	
}
# ///
# /// We autosave the EGU and CALC so we can easily change units.
# /// The default units are pico coulombs.
# ///
record(calc, "BL99:Det:N1:PChargeIntegrated_pC")
{
   field(INPA, "BL99:Det:N1:PChargeIntegrated_RBV")
   field(CALC, "A*1e12")
   field(EGU, "pC")
   info(autosaveFields, "EGU CALC")   
}

# /// 
# /// Allocate space for NDArray buffer. This can either be called by hand after
# /// modifying the pixel ID ranges or max TOF. It's called automatically on
# /// a start if any of those params have been changed, and the function hasn't already
# /// been called.
# ///
record(bo, "BL99:Det:N1:AllocSpace")
{
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(N1,0,5)ADNED_ALLOC_SPACE")
}
record(mbbi, "BL99:Det:N1:AllocSpaceStatus_RBV")
{
    field(DTYP,"asynInt32")
    field(INP, "@asyn(N1,0,5)ADNED_ALLOC_SPACE_STATUS")
    field(ZRST,"Ok")
    field(ZRVL, "0")
    field(ZRSV, "NO_ALARM")
    field(ONST, "Required")
    field(ONVL, "1")
    field(ONSV, "NO_ALARM")
    field(TWST, "Failed")
    field(TWVL, "2")
    field(TWSV, "MAJOR")
    field(SCAN, "I/O Intr")
}

# ///
# /// Disable this ADBase record scanning.
# ///
#record(ai, "BL99:Det:N1:PoolUsedMem")
#{
#   field(SCAN, "Passive")
#}

# ///
# /// Use this Start record to do callback when we have completed
# /// start process. The standard Acquire record blocks until we stop.
# /// It initially resets the downstream ROIStat plugins.
# ///
record(bo, "BL99:Det:N1:Start") {
   field(VAL, "1")
   field(OUT, "BL99:Det:N1:ResetPlugins.PROC PP")
   field(FLNK, "BL99:Det:N1:StartProc.PROC")
}
record(bo, "BL99:Det:N1:StartProc") {
   field(VAL, "1")
   field(OUT, "BL99:Det:N1:StartBusy PP")
   field(FLNK, "BL99:Det:N1:ClearPause")
}
record(busy, "BL99:Det:N1:StartBusy") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(N1,0,5)ADNED_START")
   field(ZNAM, "Done")
   field(ONAM, "Acquire")
   field(VAL,  "0")
}

# ///
# /// Use this Stop record to do callback when we have completed
# /// stop process. This will ensure that all the monitors have been 
# /// stopped and the status PVs updated.
# ///
record(bo, "BL99:Det:N1:Stop") {
   field(VAL, "1")
   field(OUT, "BL99:Det:N1:StopBusy PP")
   field(FLNK, "BL99:Det:N1:ClearPause")	
}
record(busy, "BL99:Det:N1:StopBusy") {
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(N1,0,5)ADNED_STOP")
   field(ZNAM, "Stopped")
   field(ONAM, "Stopping")
   field(VAL,  "0")
}

# ///
# /// Stop ADnED is we are busy. This is a useful if we have
# /// high level software that wants to stop before starting, wether
# /// of not we are actually running. This only issues a real stop
# /// if we are in acquire state. 
# ///
record(calcout, "BL99:Det:N1:StopIfBusy") {
   field(INPA, "BL99:Det:N1:DetectorState_RBV")
   field(CALC, "A=1")
   field(OOPT, "When Non-zero")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Stop PP")
}

# /// 
# /// Pause counting (to pause a run). Enable this to stop counting
# /// and enable it to start where counting left off. The monitors
# /// are still enabled, we just ignore events if this is enabled.
# /// A Stop or Start will clear this. 
# ///
record(bo, "BL99:Det:N1:Pause")
{
    field(DTYP,"asynInt32")
    field(OUT, "@asyn(N1,0,5)ADNED_PAUSE")
    field(ZNAM,"Not Paused")  
    field(ONAM,"Paused")
    field(OSV, "MINOR")
    info(archive, "Monitor, 00:00:01, VAL")
}
record(bo, "BL99:Det:N1:ClearPause")
{
    field(OUT, "BL99:Det:N1:Pause PP")
    field(VAL,"0")  
}

# ///
# /// Add EGU field to ArrayRate_RBV
# ///
record(calc, "BL99:Det:N1:ArrayRate_RBV")
{
    field(EGU, "Hz")
}

# ///
# /// Add archive tag to DetectorState_RBV
# ///
record(mbbi, "BL99:Det:N1:DetectorState_RBV")
{
   info(archive, "Monitor, 00:00:01, VAL")   
}


##########################################################################
# Include V4 channel specific records (needs to be 0-based).


#####################################################################
#
# areaDetector nED client template file. This is the 
# template that should be instantiated in the ADnED.template 
# file for each pvAccess channel.
#
# Matt Pearson
# Nov 14
#
# Macros:
# P - base PV name
# ADNED - middle part of PV name (eg: BL99:Det:N1:Det1:TOF:Array)
# PORT - Asyn port name
# CHAN - Asyn address (0-based. Max value is 3.)
# TIMEOUT - Asyn timeout
#
#####################################################################

# ///
# /// The V4 pvAccess PV name for channel 0
# ///
record(waveform, "BL99:Det:N1:PVName0")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,0,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Readback for the V4 pvAccess PV name for channel 0
# ///
record(waveform, "BL99:Det:N1:PVName0_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,0,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# ///
# /// Number of V4 packets in current acquisition from channel 0
# ///
record(longin, "BL99:Det:N1:SeqCounter0_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_COUNTER")
   field(SCAN, "I/O Intr")
}

# ///
# /// Sequence ID values (the timeStamp.userTag) for channel 0. 
# /// This is not the pulse ID. It is a unique ID sent by the server 
# /// with every V4 packet. So there may be multiple packets with the 
# /// same ID. Note: the timeStamp NT is used to delineate pulses.
# ///
record(longin, "BL99:Det:N1:SeqID0_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_ID")
   field(SCAN, "I/O Intr")
}
record(calc, "BL99:Det:N1:SeqID0Rate_RBV")
{
    field(INPA, "BL99:Det:N1:SeqID0Rate_RBV.B NPP NMS") 
    field(INPB, "BL99:Det:N1:SeqID0_RBV NPP NMS")
    field(INPC, "1.0")                         
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}




#####################################################################
#
# areaDetector nED client template file. This is the 
# template that should be instantiated in the ADnED.template 
# file for each pvAccess channel.
#
# Matt Pearson
# Nov 14
#
# Macros:
# P - base PV name
# ADNED - middle part of PV name (eg: BL99:Det:N1:Det1:TOF:Array)
# PORT - Asyn port name
# CHAN - Asyn address (0-based. Max value is 3.)
# TIMEOUT - Asyn timeout
#
#####################################################################

# ///
# /// The V4 pvAccess PV name for channel 1
# ///
record(waveform, "BL99:Det:N1:PVName1")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Readback for the V4 pvAccess PV name for channel 1
# ///
record(waveform, "BL99:Det:N1:PVName1_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# ///
# /// Number of V4 packets in current acquisition from channel 1
# ///
record(longin, "BL99:Det:N1:SeqCounter1_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_SEQ_COUNTER")
   field(SCAN, "I/O Intr")
}

# ///
# /// Sequence ID values (the timeStamp.userTag) for channel 1. 
# /// This is not the pulse ID. It is a unique ID sent by the server 
# /// with every V4 packet. So there may be multiple packets with the 
# /// same ID. Note: the timeStamp NT is used to delineate pulses.
# ///
record(longin, "BL99:Det:N1:SeqID1_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_SEQ_ID")
   field(SCAN, "I/O Intr")
}
record(calc, "BL99:Det:N1:SeqID1Rate_RBV")
{
    field(INPA, "BL99:Det:N1:SeqID1Rate_RBV.B NPP NMS") 
    field(INPB, "BL99:Det:N1:SeqID1_RBV NPP NMS")
    field(INPC, "1.0")                         
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}




#####################################################################
#
# areaDetector nED client template file. This is the 
# template that should be instantiated in the ADnED.template 
# file for each pvAccess channel.
#
# Matt Pearson
# Nov 14
#
# Macros:
# P - base PV name
# ADNED - middle part of PV name (eg: BL99:Det:N1:Det1:TOF:Array)
# PORT - Asyn port name
# CHAN - Asyn address (0-based. Max value is 3.)
# TIMEOUT - Asyn timeout
#
#####################################################################

# ///
# /// The V4 pvAccess PV name for channel 2
# ///
record(waveform, "BL99:Det:N1:PVName2")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Readback for the V4 pvAccess PV name for channel 2
# ///
record(waveform, "BL99:Det:N1:PVName2_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# ///
# /// Number of V4 packets in current acquisition from channel 2
# ///
record(longin, "BL99:Det:N1:SeqCounter2_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_SEQ_COUNTER")
   field(SCAN, "I/O Intr")
}

# ///
# /// Sequence ID values (the timeStamp.userTag) for channel 2. 
# /// This is not the pulse ID. It is a unique ID sent by the server 
# /// with every V4 packet. So there may be multiple packets with the 
# /// same ID. Note: the timeStamp NT is used to delineate pulses.
# ///
record(longin, "BL99:Det:N1:SeqID2_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_SEQ_ID")
   field(SCAN, "I/O Intr")
}
record(calc, "BL99:Det:N1:SeqID2Rate_RBV")
{
    field(INPA, "BL99:Det:N1:SeqID2Rate_RBV.B NPP NMS") 
    field(INPB, "BL99:Det:N1:SeqID2_RBV NPP NMS")
    field(INPC, "1.0")                         
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}




#####################################################################
#
# areaDetector nED client template file. This is the 
# template that should be instantiated in the ADnED.template 
# file for each pvAccess channel.
#
# Matt Pearson
# Nov 14
#
# Macros:
# P - base PV name
# ADNED - middle part of PV name (eg: BL99:Det:N1:Det1:TOF:Array)
# PORT - Asyn port name
# CHAN - Asyn address (0-based. Max value is 3.)
# TIMEOUT - Asyn timeout
#
#####################################################################

# ///
# /// The V4 pvAccess PV name for channel 3
# ///
record(waveform, "BL99:Det:N1:PVName3")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Readback for the V4 pvAccess PV name for channel 3
# ///
record(waveform, "BL99:Det:N1:PVName3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_PV_NAME")
    field(FTVL, "CHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# ///
# /// Number of V4 packets in current acquisition from channel 3
# ///
record(longin, "BL99:Det:N1:SeqCounter3_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_SEQ_COUNTER")
   field(SCAN, "I/O Intr")
}

# ///
# /// Sequence ID values (the timeStamp.userTag) for channel 3. 
# /// This is not the pulse ID. It is a unique ID sent by the server 
# /// with every V4 packet. So there may be multiple packets with the 
# /// same ID. Note: the timeStamp NT is used to delineate pulses.
# ///
record(longin, "BL99:Det:N1:SeqID3_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_SEQ_ID")
   field(SCAN, "I/O Intr")
}
record(calc, "BL99:Det:N1:SeqID3Rate_RBV")
{
    field(INPA, "BL99:Det:N1:SeqID3Rate_RBV.B NPP NMS") 
    field(INPB, "BL99:Det:N1:SeqID3_RBV NPP NMS")
    field(INPC, "1.0")                         
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}




##########################################################################
# Include detector specific records (needs to be 1-based).

# ///
# /// Reset the ROIStat plugins. 
# /// This is handled for each DET in ADnEDDetector.template.
# ///
record(dfanout, "BL99:Det:N1:ResetPlugins") {
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det1:ResetROIStat PP")
   field(OUTB, "BL99:Det:N1:Det2:ResetROIStat PP")
   field(OUTC, "BL99:Det:N1:Det3:ResetROIStat PP")
   field(OUTD, "BL99:Det:N1:Det4:ResetROIStat PP")
}



#####################################################################
#
# areaDetector nED client template file. This should be included by the
# top level template file. It defines the records that are specific to
# a single detector.
#
# Matt Pearson
# Sept 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# TOFSIZE - The maximum size of the TOF spectrum (eg. 160000)
# TOFXSIZE - The size of the waveform for the DETX TOF spectrum
#
#####################################################################

# ///
# /// Set the description name for this detector
# ///
record(stringout, "BL99:Det:N1:Det1:Description")
{
   field(DESC, "Description")
   field(VAL, " ")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}


#####################################################################
# Set pixel ID ranges for this detector

# ///
# /// Set the start of the pixel range for this detector DET=1
# ///
record(longout, "BL99:Det:N1:Det1:PixelNumStart")
{
   field(DESC, "Pixel range start DET1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the start of the pixel range for this detector DET=1
# ///
record(longin, "BL99:Det:N1:Det1:PixelNumStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_START")
   field(SCAN, "I/O Intr")
}


# ///
# /// Set the end of the pixel range for this detector DET=1
# ///
record(longout, "BL99:Det:N1:Det1:PixelNumEnd")
{
   field(DESC, "Pixel range end DET1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_END")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the end of the pixel range for this detector DET=1
# ///
record(longin, "BL99:Det:N1:Det1:PixelNumEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the size of the pixel range for this detector DET=1
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longout, "BL99:Det:N1:Det1:PixelNumSize")
{
   field(DESC, "Pixel range size DET1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the size of the pixel range for this detector DET=1
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longin, "BL99:Det:N1:Det1:PixelNumSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the number of time-of-flight bins for this detector DET=1
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longout, "BL99:Det:N1:Det1:TOFNumBins")
{
   field(DESC, "Number of TOF bins DET1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_NUM_BINS")
   field(VAL, "1")
   field(DRVL, "1")
   field(DRVH, "160000")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the number of time-of-flight bins for this detector DET=1
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longin, "BL99:Det:N1:Det1:TOFNumBins_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_NUM_BINS")
   field(SCAN, "I/O Intr")
}

# ///
# /// Information PV for the X or Y or Pixel ID / TOF plots to show
# /// how large a bin is in milliseconds.
# /// Bin Size in ms = (Max size / #Bins) * (Size of one bin in ms)
# /// For example: 160000 / 160 * 0.0001 = 0.1ms 
# ///
record(calc, "BL99:Det:N1:Det1:XYTOFBinSize")
{
   field(DESC, "2D Plot TOF Bin Size")
   field(INPA, "BL99:Det:N1:Det1:TOFNumBins_RBV CP MS")
   field(INPB, "160000")
   field(CALC, "(B/A)*0.0001")
   field(PREC, "2")
   field(EGU, "ms")
}

# ///
# /// Choose the type of 2-D plot. The standard plot is integrating 
# /// pixel ID in X/Y space. We can also do X/TOF, Y/TOF and PixelID/TOF, providing
# /// the TOFNumBins and PixelNumSize params have been set appropriately.
# ///
record(mbbo, "BL99:Det:N1:Det1:2DType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixeID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the 2-D plot type (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det1:2DType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixelID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}

#####################################################################
# These records are read only and are used to feed back the NDArray 
# index values for this detector. This will be required for the 
# plugins that extract the detector specific data.

# ///
# /// The NDArray detector data index start for DET=1
# ///
record(longin, "BL99:Det:N1:Det1:NDArrayStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_NDARRAY_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index end for DET=1
# ///
record(longin, "BL99:Det:N1:Det1:NDArrayEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_NDARRAY_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index size for DET=1
# ///
record(longin, "BL99:Det:N1:Det1:NDArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_NDARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index start for DET=1
# ///
record(longin, "BL99:Det:N1:Det1:NDArrayTOFStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_NDARRAY_TOF_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index end for DET=1
# ///
record(longin, "BL99:Det:N1:Det1:NDArrayTOFEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_NDARRAY_TOF_END")
   field(SCAN, "I/O Intr")
}

#####################################################################
# Detector specific data feedback

# ///
# /// Event rate
# ///
record(longin, "BL99:Det:N1:Det1:EventRate_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_EVENT_RATE")
   field(SCAN, "I/O Intr")
   field(EGU, "e/s")
}

# ///
# /// Total events since last start
# ///
record(ai, "BL99:Det:N1:Det1:EventTotal_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_EVENT_TOTAL")
   field(SCAN, "I/O Intr")
   field(EGU, "Events")
   field(PREC, "3")
}

#####################################################################
# Define a TOF ROI to pre-filter the events for this detector DET=1
# This is automatically disabled if the pixel ROI filter is enabled (and visa-versa)

# ///
# /// Set the TOF ROI start for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:TOFROIFilterStart")
{
   field(DESC, "Pre TOF ROI Start")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI start for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:TOFROIFilterStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the TOF ROI size for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:TOFROIFilterSize")
{
   field(DESC, "Pre TOF ROI Size")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI size for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:TOFROIFilterSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 1
# ///
record(bo, "BL99:Det:N1:Det1:TOFROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 1 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det1:TOFROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# TOF Transformation File & Control


#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 0
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile0")
{
    field(DESC, "TOF Trans File0")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 0 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile0_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 0
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt0")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT0")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 0 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt0_RBV")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT0")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 0
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat0")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 0 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat0_RBV")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 1
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile1")
{
    field(DESC, "TOF Trans File1")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 1 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile1_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 1
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt1")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT1")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 1 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt1_RBV")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT1")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 1
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat1")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 1 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat1_RBV")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 2
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile2")
{
    field(DESC, "TOF Trans File2")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 2 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile2_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 2
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt2")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT2")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 2 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt2_RBV")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT2")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 2
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat2")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 2 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat2_RBV")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 3
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile3")
{
    field(DESC, "TOF Trans File3")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 3 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 3
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt3")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT3")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 3 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt3_RBV")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT3")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 3
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat3")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 3 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat3_RBV")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 4
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile4")
{
    field(DESC, "TOF Trans File4")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 4 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 4
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt4")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT4")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 4 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt4_RBV")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT4")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 4
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat4")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 4 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat4_RBV")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 5
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile5")
{
    field(DESC, "TOF Trans File5")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 5 Readback
# ///
record(waveform, "BL99:Det:N1:Det1:TOFTransFile5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 5
# ///
record(longout, "BL99:Det:N1:Det1:TOFTransInt5")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT5")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 5 readback
# ///
record(longin, "BL99:Det:N1:Det1:TOFTransInt5_RBV")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_INT5")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 5
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransFloat5")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 5 readback
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransFloat5_RBV")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





# ///
# /// To aid debug, print TOF Transformation details to IOC shell
# ///
record(bo, "BL99:Det:N1:Det1:TOFTransPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_PRINT")
}

# ///
# /// Control debug param for this detector
# ///
record(bo, "BL99:Det:N1:Det1:TOFTransDebug")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(VAL, "0")
    field(PINI, "YES")
    field(ASG, "BEAMLINE")
}
record(bi, "BL99:Det:N1:Det1:TOFTransDebug_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(SCAN, "I/O Intr")
}

# ///
# /// Choose the type of TOF transformation applied. This list
# /// should match what is defined in the ADnEDTransform class.
# /// Default is None, which also disables the scale factor and offset.
# ///
record(mbbo, "BL99:Det:N1:Det1:TOFTransType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the TOF transformation (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det1:TOFTransType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Scale factor and offset (in horizontal direction) for TOF spectrum
# This can be useful for binning the TOF spectrum, particulary after
# a TOF transformation. These records have no effect if there is
# no transformation enabled or loaded.

# ///
# /// Set the TOF offset
# /// For no offset, set this to 0
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransOffset")
{
   field(DESC, "TOF Filter Offset")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(VAL, "0")
   field(PREC, "2")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF offset
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransOffset_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

# ///
# /// Set the TOF scale factor
# /// Set this to 1 for no scaling.
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det1:TOFTransScale")
{
   field(DESC, "TOF Filter Scale")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_SCALE")
   field(VAL, "1")
   field(PREC, "2")	
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF scale factor
# ///
record(ai, "BL99:Det:N1:Det1:TOFTransScale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_TOF_TRANS_SCALE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

#####################################################################
# Pixel mapping file & control

# ///
# /// Pixel Map File
# /// This is loaded into an array, which is used to map the pixel
# /// ID to a new location in the detector array. 
# ///
record(waveform, "BL99:Det:N1:Det1:PixelMapFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Pixel Map File Readback
# ///
record(waveform, "BL99:Det:N1:Det1:PixelMapFile_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// To aid debug, print pixel map array to IOC shell
# ///
record(bo, "BL99:Det:N1:Det1:PixelMapPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_MAP_PRINT")
}

# ///
# /// Enable pixel mapping for DET 1
# ///
record(bo, "BL99:Det:N1:Det1:PixelMapEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

# ///
# /// Enable pixel mapping for DET 1 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det1:PixelMapEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# Define a Pixel X/Y ROI to pre-filter the events for this detector DET=1
# This is automatically disabled if the TOF ROI filter is enabled (and visa-versa)
# The filter is applied after the pixel mapping is done. If there is no 
# pixel mapping enabled, or defined, then the ROI filter is still applied (but
# it might not make much sense).

# ///
# /// Set the Pixel XY ROI start X for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:PixelROIFilterStartX")
{
   field(DESC, "Pre Pixel ROI Start X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_START_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start X for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:PixelROIFilterStartX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_START_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size X for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:PixelROIFilterSizeX")
{
   field(DESC, "Pre Pixel ROI Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size X for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:PixelROIFilterSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI start Y for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:PixelROIFilterStartY")
{
   field(DESC, "Pre Pixel ROI Start Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start Y for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:PixelROIFilterStartY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size Y for DET 1
# ///
record(longout, "BL99:Det:N1:Det1:PixelROIFilterSizeY")
{
   field(DESC, "Pre Pixel ROI Size Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size Y for DET 1
# ///
record(longin, "BL99:Det:N1:Det1:PixelROIFilterSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the pixel ID X size for DET 1. This should match
# /// the value used for the initial ROI plugin that converts
# /// from 1-D to 2-D, but I need the value here to apply the ROI filter.
# /// This is not the ROI X size, but the detector X size.
# ///
# /// For 2-D plots other than X/Y then this parameter does not
# /// match the initial ROI plugin size. This should be the number
# /// of pixels in the X dimension on the detector. For X/TOF and Y/TOF
# /// plots the X size of the resulting array is different from the 
# /// detector X size.
# ///
record(longout, "BL99:Det:N1:Det1:PixelSizeX")
{
   field(DESC, "Pixel Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_SIZE_X")
   field(VAL, "1")
   field(LOPR, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Read the pixel ID X size for DET 1
# /// This is not the ROI X size, but the detector X size.
# ///
record(longin, "BL99:Det:N1:Det1:PixelSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 1
# ///
record(bo, "BL99:Det:N1:Det1:PixelROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 1 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det1:PixelROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,1,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}


#####################################################################
# Reset the Pixel and TOF ROIStat plugins
#####################################################################

# ///
# /// Reset the pixel and TOF ROIStat plugins. Need to know how many
# /// plugins we have instantiated in ADnEDDetectorPixelPlugin and 
# /// ADnEDDetectorTOFPlugin.
# ///
record(dfanout, "BL99:Det:N1:Det1:ResetROIStat")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det1:XY:ROI:ResetAll PP")
   field(OUTB, "BL99:Det:N1:Det1:TOF:ROI:ResetAll PP")
}


#####################################################################
# Records to define the scale for the X axis plot for TOF/dE/d-space etc

record(ai, "BL99:Det:N1:Det1:TOF:XAxis_Start")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(longin, "BL99:Det:N1:Det1:TOF:XAxis_Size")
{
   field(PINI, "YES")
   field(VAL, "16000")
   field(HHSV, "MAJOR")
   info(autosaveFields, "VAL")	
}

record(calcout, "BL99:Det:N1:Det1:TOF:XAxis_SizeHIHI")
{
   field(PINI, "YES")
   field(INPA, "16000")
   field(INPB, "1")
   field(CALC, "A+1")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det1:TOF:XAxis_Size.HIHI PP")
}

record(ai, "BL99:Det:N1:Det1:TOF:XAxis_Bin")
{
   field(PINI, "YES")
   field(VAL, "1.0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(ai, "BL99:Det:N1:Det1:TOF:XAxis_End")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

# ///
# /// INPA - Start value
# /// INPB - Size of the desired scale array (must be <=NOVA)
# /// INPC - Bin size
# /// NOVA - Max size of the output array. This should match the max size of
# ///        of the TOF waveform.
# ///
record(aSub, "BL99:Det:N1:Det1:TOF:XAxis")
{
   field(INAM, "ADnEDAxisInit")
   field(SNAM, "ADnEDAxisProcess")
   field(PREC, "4")
   field(PINI, "YES")
   field(INPA, "BL99:Det:N1:Det1:TOF:XAxis_Start")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_Size")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Bin")
   field(FTA, "DOUBLE")
   field(FTB, "LONG")
   field(FTC, "DOUBLE")
   field(FTVA, "DOUBLE")
   field(NOVA, "16000")
}

#####################################################################
# Monitor initial ROI binning parameter, and optionally 
# do an automatic X-axis generate for the TOF plot.

# ///
# /// Auto scale the TOF X-Axis plot waveform
# ///
record(bi, "BL99:Det:N1:Det1:TOF:XAxis_Auto")
{
   field(DESC, "XAxis Auto Scale")
   field(PINI, "YES")
   field(VAL, "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")	
}

# ///
# /// Process BL99:Det:N1:Det1:TOF:XAxis if XAxis_Auto is enabled and the TOF binning changes
# ///
record(calcout, "BL99:Det:N1:Det1:TOF:XAxis_Auto_Proc")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:XAxis_Auto CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:BinX CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPD, "160000")
   field(CALC, "A=1")
   field(OOPT, "When Non-zero")
   field(DOPT, "Use OCAL")
   field(OCAL, "D/B")
   field(OUT, "BL99:Det:N1:Det1:TOF:XAxis_Size PP")
   field(FLNK, "BL99:Det:N1:Det1:TOF:XAxis_Auto_Proc2")
}
record(calcout, "BL99:Det:N1:Det1:TOF:XAxis_Auto_Proc2")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:XAxis_End")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_Size")
   field(CALC, "A/B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det1:TOF:XAxis_Bin PP")
   field(FLNK, "BL99:Det:N1:Det1:TOF:XAxis")
}


#####################################################################
# Provide records to convert high level ROI start and size to bins



#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:0:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:0:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:0:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:0:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:0:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:0:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:0:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:0:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:1:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:1:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:1:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:1:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:1:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:1:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:1:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:1:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:2:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:2:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:2:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:2:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:2:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:2:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:2:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:2:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:3:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:3:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:3:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:3:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:3:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:3:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:3:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:3:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:4:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:4:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:4:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:4:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:4:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:4:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:4:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:4:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:5:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:5:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:5:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:5:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:5:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:5:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:5:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:5:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:6:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:6:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:6:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:6:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:6:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:6:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:6:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:6:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:7:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:7:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:7:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:7:Min CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det1:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:7:MinX PP")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:7:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:7:Size CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det1:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det1:TOF:ROI:7:SizeX PP")
}







#####################################################################
# Add ROI rate calculations for TOF and pixel XY ROIs


# ///
# /// Count rate in Det=1, Type=TOF, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=TOF, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det1:TOF:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



# ///
# /// Count rate in Det=1, Type=XY, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=1, Type=XY, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det1:XY:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



################################################################
# Monitor the XY:ROI:1 values and use them for the X/Y ROI filter
# records above. 

record(dfanout, "BL99:Det:N1:Det1:PixelROIFilterStartXSet")
{
   field(DOL, "BL99:Det:N1:Det1:XY:ROI:1:MinX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det1:PixelROIFilterStartX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det1:PixelROIFilterSizeXSet")
{
   field(DOL, "BL99:Det:N1:Det1:XY:ROI:1:SizeX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det1:PixelROIFilterSizeX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det1:PixelROIFilterStartYSet")
{
   field(DOL, "BL99:Det:N1:Det1:XY:ROI:1:MinY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det1:PixelROIFilterStartY.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det1:PixelROIFilterSizeYSet")
{
   field(DOL, "BL99:Det:N1:Det1:XY:ROI:1:SizeY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det1:PixelROIFilterSizeY.VAL PP")
   field(PINI, "YES")
}
# and set the pixel X size (the size of the detector in the X direction)
# 2015/10/19 I commented this out because XY:Size1 cannot be used for the X/TOF or Y/TOF
# type 2-D plots. I need to set this manually on the setup screen.
#record(dfanout, "BL99:Det:N1:Det1:PixelSizeXSet")
#{
#   field(DOL, "BL99:Det:N1:Det1:XY:Size1_RBV.VAL CP")
#   field(OMSL, "closed_loop")
#   field(OUTA, "BL99:Det:N1:Det1:PixelSizeX.VAL PP")
#   field(PINI, "YES")
#}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det1:PixelROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det1:PixelROIFilterStartXSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det1:PixelROIFilterSizeXSet.PROC PP")
   field(OUTC, "BL99:Det:N1:Det1:PixelROIFilterStartYSet.PROC PP")
   field(OUTD, "BL99:Det:N1:Det1:PixelROIFilterSizeYSet.PROC PP")
#   field(OUTE, "BL99:Det:N1:Det1:PixelSizeXSet.PROC PP")
}

################################################################
# Monitor the TOF:ROI:1 values and use them for the TOF ROI filter
# records above. Take into account the ROI binning that may be used.

record(calcout, "BL99:Det:N1:Det1:TOFROIFilterStartSet")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:1:MinX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det1:TOFROIFilterStart.VAL PP")
   field(PINI, "YES")
}
record(calcout, "BL99:Det:N1:Det1:TOFROIFilterSizeSet")
{
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:1:SizeX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det1:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det1:TOFROIFilterSize.VAL PP")
   field(PINI, "YES")
}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det1:TOFROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det1:TOFROIFilterStartSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det1:TOFROIFilterSizeSet.PROC PP")
}

################################################################
# Trigger some records at startup in IOC script

record(dfanout, "BL99:Det:N1:Det1:StartupProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det1:PixelMapFile.PROC PP")
   field(OUTB, "BL99:Det:N1:Det1:PixelROIFilterProc.PROC PP")
   field(OUTC, "BL99:Det:N1:Det1:TOFROIFilterProc.PROC PP")
}


#################################################################
# Provide a parameter to reset the array for the TOF spectrum
# This is useful when moving an ROI around on the X/Y plot, when that
# ROI is filtering the TOF spectrum data during an acqusition. 
# Providing we are not using the TOF spectrum for a counting criteria, 
# this can useful to examine Bragg reflections.
#################################################################

# ///
# /// Reset the TOF spectrum array for detector 1
# ///
record(bo, "BL99:Det:N1:Det1:ResetTOFArray")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,1,5)ADNED_DET_TOF_ARRAY_RESET")
}




#####################################################################
#
# areaDetector nED client template file. This should be included by the
# top level template file. It defines the records that are specific to
# a single detector.
#
# Matt Pearson
# Sept 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# TOFSIZE - The maximum size of the TOF spectrum (eg. 160000)
# TOFXSIZE - The size of the waveform for the DETX TOF spectrum
#
#####################################################################

# ///
# /// Set the description name for this detector
# ///
record(stringout, "BL99:Det:N1:Det2:Description")
{
   field(DESC, "Description")
   field(VAL, " ")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}


#####################################################################
# Set pixel ID ranges for this detector

# ///
# /// Set the start of the pixel range for this detector DET=2
# ///
record(longout, "BL99:Det:N1:Det2:PixelNumStart")
{
   field(DESC, "Pixel range start DET2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the start of the pixel range for this detector DET=2
# ///
record(longin, "BL99:Det:N1:Det2:PixelNumStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_START")
   field(SCAN, "I/O Intr")
}


# ///
# /// Set the end of the pixel range for this detector DET=2
# ///
record(longout, "BL99:Det:N1:Det2:PixelNumEnd")
{
   field(DESC, "Pixel range end DET2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_END")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the end of the pixel range for this detector DET=2
# ///
record(longin, "BL99:Det:N1:Det2:PixelNumEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the size of the pixel range for this detector DET=2
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longout, "BL99:Det:N1:Det2:PixelNumSize")
{
   field(DESC, "Pixel range size DET2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the size of the pixel range for this detector DET=2
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longin, "BL99:Det:N1:Det2:PixelNumSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the number of time-of-flight bins for this detector DET=2
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longout, "BL99:Det:N1:Det2:TOFNumBins")
{
   field(DESC, "Number of TOF bins DET2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_NUM_BINS")
   field(VAL, "1")
   field(DRVL, "1")
   field(DRVH, "160000")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the number of time-of-flight bins for this detector DET=2
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longin, "BL99:Det:N1:Det2:TOFNumBins_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_NUM_BINS")
   field(SCAN, "I/O Intr")
}

# ///
# /// Information PV for the X or Y or Pixel ID / TOF plots to show
# /// how large a bin is in milliseconds.
# /// Bin Size in ms = (Max size / #Bins) * (Size of one bin in ms)
# /// For example: 160000 / 160 * 0.0001 = 0.1ms 
# ///
record(calc, "BL99:Det:N1:Det2:XYTOFBinSize")
{
   field(DESC, "2D Plot TOF Bin Size")
   field(INPA, "BL99:Det:N1:Det2:TOFNumBins_RBV CP MS")
   field(INPB, "160000")
   field(CALC, "(B/A)*0.0001")
   field(PREC, "2")
   field(EGU, "ms")
}

# ///
# /// Choose the type of 2-D plot. The standard plot is integrating 
# /// pixel ID in X/Y space. We can also do X/TOF, Y/TOF and PixelID/TOF, providing
# /// the TOFNumBins and PixelNumSize params have been set appropriately.
# ///
record(mbbo, "BL99:Det:N1:Det2:2DType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixeID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the 2-D plot type (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det2:2DType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixelID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}

#####################################################################
# These records are read only and are used to feed back the NDArray 
# index values for this detector. This will be required for the 
# plugins that extract the detector specific data.

# ///
# /// The NDArray detector data index start for DET=2
# ///
record(longin, "BL99:Det:N1:Det2:NDArrayStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_NDARRAY_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index end for DET=2
# ///
record(longin, "BL99:Det:N1:Det2:NDArrayEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_NDARRAY_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index size for DET=2
# ///
record(longin, "BL99:Det:N1:Det2:NDArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_NDARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index start for DET=2
# ///
record(longin, "BL99:Det:N1:Det2:NDArrayTOFStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_NDARRAY_TOF_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index end for DET=2
# ///
record(longin, "BL99:Det:N1:Det2:NDArrayTOFEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_NDARRAY_TOF_END")
   field(SCAN, "I/O Intr")
}

#####################################################################
# Detector specific data feedback

# ///
# /// Event rate
# ///
record(longin, "BL99:Det:N1:Det2:EventRate_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_EVENT_RATE")
   field(SCAN, "I/O Intr")
   field(EGU, "e/s")
}

# ///
# /// Total events since last start
# ///
record(ai, "BL99:Det:N1:Det2:EventTotal_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_EVENT_TOTAL")
   field(SCAN, "I/O Intr")
   field(EGU, "Events")
   field(PREC, "3")
}

#####################################################################
# Define a TOF ROI to pre-filter the events for this detector DET=2
# This is automatically disabled if the pixel ROI filter is enabled (and visa-versa)

# ///
# /// Set the TOF ROI start for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:TOFROIFilterStart")
{
   field(DESC, "Pre TOF ROI Start")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI start for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:TOFROIFilterStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the TOF ROI size for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:TOFROIFilterSize")
{
   field(DESC, "Pre TOF ROI Size")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI size for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:TOFROIFilterSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 2
# ///
record(bo, "BL99:Det:N1:Det2:TOFROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 2 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det2:TOFROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# TOF Transformation File & Control


#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 0
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile0")
{
    field(DESC, "TOF Trans File0")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 0 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile0_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 0
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt0")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT0")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 0 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt0_RBV")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT0")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 0
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat0")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 0 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat0_RBV")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 1
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile1")
{
    field(DESC, "TOF Trans File1")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 1 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile1_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 1
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt1")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT1")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 1 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt1_RBV")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT1")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 1
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat1")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 1 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat1_RBV")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 2
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile2")
{
    field(DESC, "TOF Trans File2")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 2 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile2_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 2
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt2")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT2")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 2 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt2_RBV")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT2")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 2
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat2")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 2 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat2_RBV")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 3
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile3")
{
    field(DESC, "TOF Trans File3")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 3 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 3
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt3")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT3")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 3 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt3_RBV")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT3")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 3
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat3")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 3 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat3_RBV")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 4
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile4")
{
    field(DESC, "TOF Trans File4")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 4 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 4
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt4")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT4")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 4 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt4_RBV")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT4")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 4
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat4")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 4 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat4_RBV")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 5
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile5")
{
    field(DESC, "TOF Trans File5")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 5 Readback
# ///
record(waveform, "BL99:Det:N1:Det2:TOFTransFile5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 5
# ///
record(longout, "BL99:Det:N1:Det2:TOFTransInt5")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT5")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 5 readback
# ///
record(longin, "BL99:Det:N1:Det2:TOFTransInt5_RBV")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_INT5")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 5
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransFloat5")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 5 readback
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransFloat5_RBV")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





# ///
# /// To aid debug, print TOF Transformation details to IOC shell
# ///
record(bo, "BL99:Det:N1:Det2:TOFTransPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_PRINT")
}

# ///
# /// Control debug param for this detector
# ///
record(bo, "BL99:Det:N1:Det2:TOFTransDebug")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(VAL, "0")
    field(PINI, "YES")
    field(ASG, "BEAMLINE")
}
record(bi, "BL99:Det:N1:Det2:TOFTransDebug_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(SCAN, "I/O Intr")
}

# ///
# /// Choose the type of TOF transformation applied. This list
# /// should match what is defined in the ADnEDTransform class.
# /// Default is None, which also disables the scale factor and offset.
# ///
record(mbbo, "BL99:Det:N1:Det2:TOFTransType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the TOF transformation (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det2:TOFTransType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Scale factor and offset (in horizontal direction) for TOF spectrum
# This can be useful for binning the TOF spectrum, particulary after
# a TOF transformation. These records have no effect if there is
# no transformation enabled or loaded.

# ///
# /// Set the TOF offset
# /// For no offset, set this to 0
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransOffset")
{
   field(DESC, "TOF Filter Offset")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(VAL, "0")
   field(PREC, "2")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF offset
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransOffset_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

# ///
# /// Set the TOF scale factor
# /// Set this to 1 for no scaling.
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det2:TOFTransScale")
{
   field(DESC, "TOF Filter Scale")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_SCALE")
   field(VAL, "1")
   field(PREC, "2")	
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF scale factor
# ///
record(ai, "BL99:Det:N1:Det2:TOFTransScale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_TOF_TRANS_SCALE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

#####################################################################
# Pixel mapping file & control

# ///
# /// Pixel Map File
# /// This is loaded into an array, which is used to map the pixel
# /// ID to a new location in the detector array. 
# ///
record(waveform, "BL99:Det:N1:Det2:PixelMapFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Pixel Map File Readback
# ///
record(waveform, "BL99:Det:N1:Det2:PixelMapFile_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// To aid debug, print pixel map array to IOC shell
# ///
record(bo, "BL99:Det:N1:Det2:PixelMapPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_MAP_PRINT")
}

# ///
# /// Enable pixel mapping for DET 2
# ///
record(bo, "BL99:Det:N1:Det2:PixelMapEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

# ///
# /// Enable pixel mapping for DET 2 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det2:PixelMapEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# Define a Pixel X/Y ROI to pre-filter the events for this detector DET=2
# This is automatically disabled if the TOF ROI filter is enabled (and visa-versa)
# The filter is applied after the pixel mapping is done. If there is no 
# pixel mapping enabled, or defined, then the ROI filter is still applied (but
# it might not make much sense).

# ///
# /// Set the Pixel XY ROI start X for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:PixelROIFilterStartX")
{
   field(DESC, "Pre Pixel ROI Start X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_START_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start X for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:PixelROIFilterStartX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_START_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size X for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:PixelROIFilterSizeX")
{
   field(DESC, "Pre Pixel ROI Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size X for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:PixelROIFilterSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI start Y for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:PixelROIFilterStartY")
{
   field(DESC, "Pre Pixel ROI Start Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start Y for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:PixelROIFilterStartY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size Y for DET 2
# ///
record(longout, "BL99:Det:N1:Det2:PixelROIFilterSizeY")
{
   field(DESC, "Pre Pixel ROI Size Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size Y for DET 2
# ///
record(longin, "BL99:Det:N1:Det2:PixelROIFilterSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the pixel ID X size for DET 2. This should match
# /// the value used for the initial ROI plugin that converts
# /// from 1-D to 2-D, but I need the value here to apply the ROI filter.
# /// This is not the ROI X size, but the detector X size.
# ///
# /// For 2-D plots other than X/Y then this parameter does not
# /// match the initial ROI plugin size. This should be the number
# /// of pixels in the X dimension on the detector. For X/TOF and Y/TOF
# /// plots the X size of the resulting array is different from the 
# /// detector X size.
# ///
record(longout, "BL99:Det:N1:Det2:PixelSizeX")
{
   field(DESC, "Pixel Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_SIZE_X")
   field(VAL, "1")
   field(LOPR, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Read the pixel ID X size for DET 2
# /// This is not the ROI X size, but the detector X size.
# ///
record(longin, "BL99:Det:N1:Det2:PixelSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 2
# ///
record(bo, "BL99:Det:N1:Det2:PixelROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 2 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det2:PixelROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,2,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}


#####################################################################
# Reset the Pixel and TOF ROIStat plugins
#####################################################################

# ///
# /// Reset the pixel and TOF ROIStat plugins. Need to know how many
# /// plugins we have instantiated in ADnEDDetectorPixelPlugin and 
# /// ADnEDDetectorTOFPlugin.
# ///
record(dfanout, "BL99:Det:N1:Det2:ResetROIStat")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det2:XY:ROI:ResetAll PP")
   field(OUTB, "BL99:Det:N1:Det2:TOF:ROI:ResetAll PP")
}


#####################################################################
# Records to define the scale for the X axis plot for TOF/dE/d-space etc

record(ai, "BL99:Det:N1:Det2:TOF:XAxis_Start")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(longin, "BL99:Det:N1:Det2:TOF:XAxis_Size")
{
   field(PINI, "YES")
   field(VAL, "16000")
   field(HHSV, "MAJOR")
   info(autosaveFields, "VAL")	
}

record(calcout, "BL99:Det:N1:Det2:TOF:XAxis_SizeHIHI")
{
   field(PINI, "YES")
   field(INPA, "16000")
   field(INPB, "1")
   field(CALC, "A+1")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det2:TOF:XAxis_Size.HIHI PP")
}

record(ai, "BL99:Det:N1:Det2:TOF:XAxis_Bin")
{
   field(PINI, "YES")
   field(VAL, "1.0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(ai, "BL99:Det:N1:Det2:TOF:XAxis_End")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

# ///
# /// INPA - Start value
# /// INPB - Size of the desired scale array (must be <=NOVA)
# /// INPC - Bin size
# /// NOVA - Max size of the output array. This should match the max size of
# ///        of the TOF waveform.
# ///
record(aSub, "BL99:Det:N1:Det2:TOF:XAxis")
{
   field(INAM, "ADnEDAxisInit")
   field(SNAM, "ADnEDAxisProcess")
   field(PREC, "4")
   field(PINI, "YES")
   field(INPA, "BL99:Det:N1:Det2:TOF:XAxis_Start")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_Size")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Bin")
   field(FTA, "DOUBLE")
   field(FTB, "LONG")
   field(FTC, "DOUBLE")
   field(FTVA, "DOUBLE")
   field(NOVA, "16000")
}

#####################################################################
# Monitor initial ROI binning parameter, and optionally 
# do an automatic X-axis generate for the TOF plot.

# ///
# /// Auto scale the TOF X-Axis plot waveform
# ///
record(bi, "BL99:Det:N1:Det2:TOF:XAxis_Auto")
{
   field(DESC, "XAxis Auto Scale")
   field(PINI, "YES")
   field(VAL, "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")	
}

# ///
# /// Process BL99:Det:N1:Det2:TOF:XAxis if XAxis_Auto is enabled and the TOF binning changes
# ///
record(calcout, "BL99:Det:N1:Det2:TOF:XAxis_Auto_Proc")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:XAxis_Auto CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:BinX CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPD, "160000")
   field(CALC, "A=1")
   field(OOPT, "When Non-zero")
   field(DOPT, "Use OCAL")
   field(OCAL, "D/B")
   field(OUT, "BL99:Det:N1:Det2:TOF:XAxis_Size PP")
   field(FLNK, "BL99:Det:N1:Det2:TOF:XAxis_Auto_Proc2")
}
record(calcout, "BL99:Det:N1:Det2:TOF:XAxis_Auto_Proc2")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:XAxis_End")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_Size")
   field(CALC, "A/B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det2:TOF:XAxis_Bin PP")
   field(FLNK, "BL99:Det:N1:Det2:TOF:XAxis")
}


#####################################################################
# Provide records to convert high level ROI start and size to bins



#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:0:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:0:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:0:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:0:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:0:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:0:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:0:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:0:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:1:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:1:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:1:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:1:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:1:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:1:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:1:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:1:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:2:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:2:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:2:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:2:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:2:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:2:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:2:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:2:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:3:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:3:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:3:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:3:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:3:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:3:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:3:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:3:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:4:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:4:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:4:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:4:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:4:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:4:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:4:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:4:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:5:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:5:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:5:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:5:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:5:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:5:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:5:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:5:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:6:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:6:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:6:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:6:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:6:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:6:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:6:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:6:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:7:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:7:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:7:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:7:Min CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det2:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:7:MinX PP")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:7:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:7:Size CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det2:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det2:TOF:ROI:7:SizeX PP")
}







#####################################################################
# Add ROI rate calculations for TOF and pixel XY ROIs


# ///
# /// Count rate in Det=2, Type=TOF, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=TOF, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det2:TOF:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



# ///
# /// Count rate in Det=2, Type=XY, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=2, Type=XY, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det2:XY:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



################################################################
# Monitor the XY:ROI:1 values and use them for the X/Y ROI filter
# records above. 

record(dfanout, "BL99:Det:N1:Det2:PixelROIFilterStartXSet")
{
   field(DOL, "BL99:Det:N1:Det2:XY:ROI:1:MinX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det2:PixelROIFilterStartX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det2:PixelROIFilterSizeXSet")
{
   field(DOL, "BL99:Det:N1:Det2:XY:ROI:1:SizeX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det2:PixelROIFilterSizeX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det2:PixelROIFilterStartYSet")
{
   field(DOL, "BL99:Det:N1:Det2:XY:ROI:1:MinY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det2:PixelROIFilterStartY.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det2:PixelROIFilterSizeYSet")
{
   field(DOL, "BL99:Det:N1:Det2:XY:ROI:1:SizeY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det2:PixelROIFilterSizeY.VAL PP")
   field(PINI, "YES")
}
# and set the pixel X size (the size of the detector in the X direction)
# 2015/10/19 I commented this out because XY:Size1 cannot be used for the X/TOF or Y/TOF
# type 2-D plots. I need to set this manually on the setup screen.
#record(dfanout, "BL99:Det:N1:Det2:PixelSizeXSet")
#{
#   field(DOL, "BL99:Det:N1:Det2:XY:Size1_RBV.VAL CP")
#   field(OMSL, "closed_loop")
#   field(OUTA, "BL99:Det:N1:Det2:PixelSizeX.VAL PP")
#   field(PINI, "YES")
#}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det2:PixelROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det2:PixelROIFilterStartXSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det2:PixelROIFilterSizeXSet.PROC PP")
   field(OUTC, "BL99:Det:N1:Det2:PixelROIFilterStartYSet.PROC PP")
   field(OUTD, "BL99:Det:N1:Det2:PixelROIFilterSizeYSet.PROC PP")
#   field(OUTE, "BL99:Det:N1:Det2:PixelSizeXSet.PROC PP")
}

################################################################
# Monitor the TOF:ROI:1 values and use them for the TOF ROI filter
# records above. Take into account the ROI binning that may be used.

record(calcout, "BL99:Det:N1:Det2:TOFROIFilterStartSet")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:1:MinX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det2:TOFROIFilterStart.VAL PP")
   field(PINI, "YES")
}
record(calcout, "BL99:Det:N1:Det2:TOFROIFilterSizeSet")
{
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:1:SizeX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det2:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det2:TOFROIFilterSize.VAL PP")
   field(PINI, "YES")
}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det2:TOFROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det2:TOFROIFilterStartSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det2:TOFROIFilterSizeSet.PROC PP")
}

################################################################
# Trigger some records at startup in IOC script

record(dfanout, "BL99:Det:N1:Det2:StartupProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det2:PixelMapFile.PROC PP")
   field(OUTB, "BL99:Det:N1:Det2:PixelROIFilterProc.PROC PP")
   field(OUTC, "BL99:Det:N1:Det2:TOFROIFilterProc.PROC PP")
}


#################################################################
# Provide a parameter to reset the array for the TOF spectrum
# This is useful when moving an ROI around on the X/Y plot, when that
# ROI is filtering the TOF spectrum data during an acqusition. 
# Providing we are not using the TOF spectrum for a counting criteria, 
# this can useful to examine Bragg reflections.
#################################################################

# ///
# /// Reset the TOF spectrum array for detector 2
# ///
record(bo, "BL99:Det:N1:Det2:ResetTOFArray")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,2,5)ADNED_DET_TOF_ARRAY_RESET")
}




#####################################################################
#
# areaDetector nED client template file. This should be included by the
# top level template file. It defines the records that are specific to
# a single detector.
#
# Matt Pearson
# Sept 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# TOFSIZE - The maximum size of the TOF spectrum (eg. 160000)
# TOFXSIZE - The size of the waveform for the DETX TOF spectrum
#
#####################################################################

# ///
# /// Set the description name for this detector
# ///
record(stringout, "BL99:Det:N1:Det3:Description")
{
   field(DESC, "Description")
   field(VAL, " ")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}


#####################################################################
# Set pixel ID ranges for this detector

# ///
# /// Set the start of the pixel range for this detector DET=3
# ///
record(longout, "BL99:Det:N1:Det3:PixelNumStart")
{
   field(DESC, "Pixel range start DET3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the start of the pixel range for this detector DET=3
# ///
record(longin, "BL99:Det:N1:Det3:PixelNumStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_START")
   field(SCAN, "I/O Intr")
}


# ///
# /// Set the end of the pixel range for this detector DET=3
# ///
record(longout, "BL99:Det:N1:Det3:PixelNumEnd")
{
   field(DESC, "Pixel range end DET3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_END")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the end of the pixel range for this detector DET=3
# ///
record(longin, "BL99:Det:N1:Det3:PixelNumEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the size of the pixel range for this detector DET=3
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longout, "BL99:Det:N1:Det3:PixelNumSize")
{
   field(DESC, "Pixel range size DET3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the size of the pixel range for this detector DET=3
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longin, "BL99:Det:N1:Det3:PixelNumSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the number of time-of-flight bins for this detector DET=3
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longout, "BL99:Det:N1:Det3:TOFNumBins")
{
   field(DESC, "Number of TOF bins DET3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_NUM_BINS")
   field(VAL, "1")
   field(DRVL, "1")
   field(DRVH, "160000")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the number of time-of-flight bins for this detector DET=3
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longin, "BL99:Det:N1:Det3:TOFNumBins_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_NUM_BINS")
   field(SCAN, "I/O Intr")
}

# ///
# /// Information PV for the X or Y or Pixel ID / TOF plots to show
# /// how large a bin is in milliseconds.
# /// Bin Size in ms = (Max size / #Bins) * (Size of one bin in ms)
# /// For example: 160000 / 160 * 0.0001 = 0.1ms 
# ///
record(calc, "BL99:Det:N1:Det3:XYTOFBinSize")
{
   field(DESC, "2D Plot TOF Bin Size")
   field(INPA, "BL99:Det:N1:Det3:TOFNumBins_RBV CP MS")
   field(INPB, "160000")
   field(CALC, "(B/A)*0.0001")
   field(PREC, "2")
   field(EGU, "ms")
}

# ///
# /// Choose the type of 2-D plot. The standard plot is integrating 
# /// pixel ID in X/Y space. We can also do X/TOF, Y/TOF and PixelID/TOF, providing
# /// the TOFNumBins and PixelNumSize params have been set appropriately.
# ///
record(mbbo, "BL99:Det:N1:Det3:2DType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixeID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the 2-D plot type (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det3:2DType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixelID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}

#####################################################################
# These records are read only and are used to feed back the NDArray 
# index values for this detector. This will be required for the 
# plugins that extract the detector specific data.

# ///
# /// The NDArray detector data index start for DET=3
# ///
record(longin, "BL99:Det:N1:Det3:NDArrayStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_NDARRAY_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index end for DET=3
# ///
record(longin, "BL99:Det:N1:Det3:NDArrayEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_NDARRAY_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index size for DET=3
# ///
record(longin, "BL99:Det:N1:Det3:NDArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_NDARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index start for DET=3
# ///
record(longin, "BL99:Det:N1:Det3:NDArrayTOFStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_NDARRAY_TOF_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index end for DET=3
# ///
record(longin, "BL99:Det:N1:Det3:NDArrayTOFEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_NDARRAY_TOF_END")
   field(SCAN, "I/O Intr")
}

#####################################################################
# Detector specific data feedback

# ///
# /// Event rate
# ///
record(longin, "BL99:Det:N1:Det3:EventRate_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_EVENT_RATE")
   field(SCAN, "I/O Intr")
   field(EGU, "e/s")
}

# ///
# /// Total events since last start
# ///
record(ai, "BL99:Det:N1:Det3:EventTotal_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_EVENT_TOTAL")
   field(SCAN, "I/O Intr")
   field(EGU, "Events")
   field(PREC, "3")
}

#####################################################################
# Define a TOF ROI to pre-filter the events for this detector DET=3
# This is automatically disabled if the pixel ROI filter is enabled (and visa-versa)

# ///
# /// Set the TOF ROI start for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:TOFROIFilterStart")
{
   field(DESC, "Pre TOF ROI Start")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI start for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:TOFROIFilterStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the TOF ROI size for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:TOFROIFilterSize")
{
   field(DESC, "Pre TOF ROI Size")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI size for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:TOFROIFilterSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 3
# ///
record(bo, "BL99:Det:N1:Det3:TOFROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 3 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det3:TOFROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# TOF Transformation File & Control


#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 0
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile0")
{
    field(DESC, "TOF Trans File0")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 0 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile0_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 0
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt0")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT0")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 0 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt0_RBV")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT0")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 0
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat0")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 0 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat0_RBV")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 1
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile1")
{
    field(DESC, "TOF Trans File1")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 1 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile1_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 1
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt1")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT1")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 1 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt1_RBV")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT1")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 1
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat1")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 1 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat1_RBV")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 2
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile2")
{
    field(DESC, "TOF Trans File2")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 2 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile2_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 2
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt2")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT2")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 2 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt2_RBV")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT2")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 2
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat2")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 2 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat2_RBV")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 3
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile3")
{
    field(DESC, "TOF Trans File3")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 3 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 3
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt3")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT3")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 3 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt3_RBV")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT3")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 3
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat3")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 3 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat3_RBV")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 4
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile4")
{
    field(DESC, "TOF Trans File4")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 4 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 4
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt4")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT4")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 4 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt4_RBV")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT4")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 4
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat4")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 4 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat4_RBV")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 5
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile5")
{
    field(DESC, "TOF Trans File5")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 5 Readback
# ///
record(waveform, "BL99:Det:N1:Det3:TOFTransFile5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 5
# ///
record(longout, "BL99:Det:N1:Det3:TOFTransInt5")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT5")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 5 readback
# ///
record(longin, "BL99:Det:N1:Det3:TOFTransInt5_RBV")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_INT5")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 5
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransFloat5")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 5 readback
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransFloat5_RBV")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





# ///
# /// To aid debug, print TOF Transformation details to IOC shell
# ///
record(bo, "BL99:Det:N1:Det3:TOFTransPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_PRINT")
}

# ///
# /// Control debug param for this detector
# ///
record(bo, "BL99:Det:N1:Det3:TOFTransDebug")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(VAL, "0")
    field(PINI, "YES")
    field(ASG, "BEAMLINE")
}
record(bi, "BL99:Det:N1:Det3:TOFTransDebug_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(SCAN, "I/O Intr")
}

# ///
# /// Choose the type of TOF transformation applied. This list
# /// should match what is defined in the ADnEDTransform class.
# /// Default is None, which also disables the scale factor and offset.
# ///
record(mbbo, "BL99:Det:N1:Det3:TOFTransType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the TOF transformation (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det3:TOFTransType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Scale factor and offset (in horizontal direction) for TOF spectrum
# This can be useful for binning the TOF spectrum, particulary after
# a TOF transformation. These records have no effect if there is
# no transformation enabled or loaded.

# ///
# /// Set the TOF offset
# /// For no offset, set this to 0
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransOffset")
{
   field(DESC, "TOF Filter Offset")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(VAL, "0")
   field(PREC, "2")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF offset
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransOffset_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

# ///
# /// Set the TOF scale factor
# /// Set this to 1 for no scaling.
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det3:TOFTransScale")
{
   field(DESC, "TOF Filter Scale")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_SCALE")
   field(VAL, "1")
   field(PREC, "2")	
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF scale factor
# ///
record(ai, "BL99:Det:N1:Det3:TOFTransScale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_TOF_TRANS_SCALE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

#####################################################################
# Pixel mapping file & control

# ///
# /// Pixel Map File
# /// This is loaded into an array, which is used to map the pixel
# /// ID to a new location in the detector array. 
# ///
record(waveform, "BL99:Det:N1:Det3:PixelMapFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Pixel Map File Readback
# ///
record(waveform, "BL99:Det:N1:Det3:PixelMapFile_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// To aid debug, print pixel map array to IOC shell
# ///
record(bo, "BL99:Det:N1:Det3:PixelMapPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_MAP_PRINT")
}

# ///
# /// Enable pixel mapping for DET 3
# ///
record(bo, "BL99:Det:N1:Det3:PixelMapEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

# ///
# /// Enable pixel mapping for DET 3 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det3:PixelMapEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# Define a Pixel X/Y ROI to pre-filter the events for this detector DET=3
# This is automatically disabled if the TOF ROI filter is enabled (and visa-versa)
# The filter is applied after the pixel mapping is done. If there is no 
# pixel mapping enabled, or defined, then the ROI filter is still applied (but
# it might not make much sense).

# ///
# /// Set the Pixel XY ROI start X for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:PixelROIFilterStartX")
{
   field(DESC, "Pre Pixel ROI Start X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_START_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start X for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:PixelROIFilterStartX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_START_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size X for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:PixelROIFilterSizeX")
{
   field(DESC, "Pre Pixel ROI Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size X for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:PixelROIFilterSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI start Y for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:PixelROIFilterStartY")
{
   field(DESC, "Pre Pixel ROI Start Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start Y for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:PixelROIFilterStartY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size Y for DET 3
# ///
record(longout, "BL99:Det:N1:Det3:PixelROIFilterSizeY")
{
   field(DESC, "Pre Pixel ROI Size Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size Y for DET 3
# ///
record(longin, "BL99:Det:N1:Det3:PixelROIFilterSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the pixel ID X size for DET 3. This should match
# /// the value used for the initial ROI plugin that converts
# /// from 1-D to 2-D, but I need the value here to apply the ROI filter.
# /// This is not the ROI X size, but the detector X size.
# ///
# /// For 2-D plots other than X/Y then this parameter does not
# /// match the initial ROI plugin size. This should be the number
# /// of pixels in the X dimension on the detector. For X/TOF and Y/TOF
# /// plots the X size of the resulting array is different from the 
# /// detector X size.
# ///
record(longout, "BL99:Det:N1:Det3:PixelSizeX")
{
   field(DESC, "Pixel Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_SIZE_X")
   field(VAL, "1")
   field(LOPR, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Read the pixel ID X size for DET 3
# /// This is not the ROI X size, but the detector X size.
# ///
record(longin, "BL99:Det:N1:Det3:PixelSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 3
# ///
record(bo, "BL99:Det:N1:Det3:PixelROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 3 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det3:PixelROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,3,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}


#####################################################################
# Reset the Pixel and TOF ROIStat plugins
#####################################################################

# ///
# /// Reset the pixel and TOF ROIStat plugins. Need to know how many
# /// plugins we have instantiated in ADnEDDetectorPixelPlugin and 
# /// ADnEDDetectorTOFPlugin.
# ///
record(dfanout, "BL99:Det:N1:Det3:ResetROIStat")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det3:XY:ROI:ResetAll PP")
   field(OUTB, "BL99:Det:N1:Det3:TOF:ROI:ResetAll PP")
}


#####################################################################
# Records to define the scale for the X axis plot for TOF/dE/d-space etc

record(ai, "BL99:Det:N1:Det3:TOF:XAxis_Start")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(longin, "BL99:Det:N1:Det3:TOF:XAxis_Size")
{
   field(PINI, "YES")
   field(VAL, "16000")
   field(HHSV, "MAJOR")
   info(autosaveFields, "VAL")	
}

record(calcout, "BL99:Det:N1:Det3:TOF:XAxis_SizeHIHI")
{
   field(PINI, "YES")
   field(INPA, "16000")
   field(INPB, "1")
   field(CALC, "A+1")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det3:TOF:XAxis_Size.HIHI PP")
}

record(ai, "BL99:Det:N1:Det3:TOF:XAxis_Bin")
{
   field(PINI, "YES")
   field(VAL, "1.0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(ai, "BL99:Det:N1:Det3:TOF:XAxis_End")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

# ///
# /// INPA - Start value
# /// INPB - Size of the desired scale array (must be <=NOVA)
# /// INPC - Bin size
# /// NOVA - Max size of the output array. This should match the max size of
# ///        of the TOF waveform.
# ///
record(aSub, "BL99:Det:N1:Det3:TOF:XAxis")
{
   field(INAM, "ADnEDAxisInit")
   field(SNAM, "ADnEDAxisProcess")
   field(PREC, "4")
   field(PINI, "YES")
   field(INPA, "BL99:Det:N1:Det3:TOF:XAxis_Start")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_Size")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Bin")
   field(FTA, "DOUBLE")
   field(FTB, "LONG")
   field(FTC, "DOUBLE")
   field(FTVA, "DOUBLE")
   field(NOVA, "16000")
}

#####################################################################
# Monitor initial ROI binning parameter, and optionally 
# do an automatic X-axis generate for the TOF plot.

# ///
# /// Auto scale the TOF X-Axis plot waveform
# ///
record(bi, "BL99:Det:N1:Det3:TOF:XAxis_Auto")
{
   field(DESC, "XAxis Auto Scale")
   field(PINI, "YES")
   field(VAL, "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")	
}

# ///
# /// Process BL99:Det:N1:Det3:TOF:XAxis if XAxis_Auto is enabled and the TOF binning changes
# ///
record(calcout, "BL99:Det:N1:Det3:TOF:XAxis_Auto_Proc")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:XAxis_Auto CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:BinX CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPD, "160000")
   field(CALC, "A=1")
   field(OOPT, "When Non-zero")
   field(DOPT, "Use OCAL")
   field(OCAL, "D/B")
   field(OUT, "BL99:Det:N1:Det3:TOF:XAxis_Size PP")
   field(FLNK, "BL99:Det:N1:Det3:TOF:XAxis_Auto_Proc2")
}
record(calcout, "BL99:Det:N1:Det3:TOF:XAxis_Auto_Proc2")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:XAxis_End")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_Size")
   field(CALC, "A/B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det3:TOF:XAxis_Bin PP")
   field(FLNK, "BL99:Det:N1:Det3:TOF:XAxis")
}


#####################################################################
# Provide records to convert high level ROI start and size to bins



#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:0:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:0:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:0:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:0:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:0:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:0:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:0:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:0:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:1:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:1:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:1:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:1:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:1:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:1:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:1:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:1:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:2:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:2:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:2:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:2:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:2:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:2:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:2:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:2:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:3:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:3:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:3:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:3:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:3:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:3:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:3:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:3:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:4:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:4:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:4:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:4:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:4:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:4:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:4:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:4:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:5:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:5:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:5:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:5:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:5:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:5:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:5:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:5:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:6:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:6:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:6:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:6:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:6:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:6:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:6:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:6:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:7:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:7:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:7:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:7:Min CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det3:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:7:MinX PP")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:7:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:7:Size CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det3:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det3:TOF:ROI:7:SizeX PP")
}







#####################################################################
# Add ROI rate calculations for TOF and pixel XY ROIs


# ///
# /// Count rate in Det=3, Type=TOF, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=TOF, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det3:TOF:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



# ///
# /// Count rate in Det=3, Type=XY, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=3, Type=XY, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det3:XY:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



################################################################
# Monitor the XY:ROI:1 values and use them for the X/Y ROI filter
# records above. 

record(dfanout, "BL99:Det:N1:Det3:PixelROIFilterStartXSet")
{
   field(DOL, "BL99:Det:N1:Det3:XY:ROI:1:MinX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det3:PixelROIFilterStartX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det3:PixelROIFilterSizeXSet")
{
   field(DOL, "BL99:Det:N1:Det3:XY:ROI:1:SizeX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det3:PixelROIFilterSizeX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det3:PixelROIFilterStartYSet")
{
   field(DOL, "BL99:Det:N1:Det3:XY:ROI:1:MinY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det3:PixelROIFilterStartY.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det3:PixelROIFilterSizeYSet")
{
   field(DOL, "BL99:Det:N1:Det3:XY:ROI:1:SizeY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det3:PixelROIFilterSizeY.VAL PP")
   field(PINI, "YES")
}
# and set the pixel X size (the size of the detector in the X direction)
# 2015/10/19 I commented this out because XY:Size1 cannot be used for the X/TOF or Y/TOF
# type 2-D plots. I need to set this manually on the setup screen.
#record(dfanout, "BL99:Det:N1:Det3:PixelSizeXSet")
#{
#   field(DOL, "BL99:Det:N1:Det3:XY:Size1_RBV.VAL CP")
#   field(OMSL, "closed_loop")
#   field(OUTA, "BL99:Det:N1:Det3:PixelSizeX.VAL PP")
#   field(PINI, "YES")
#}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det3:PixelROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det3:PixelROIFilterStartXSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det3:PixelROIFilterSizeXSet.PROC PP")
   field(OUTC, "BL99:Det:N1:Det3:PixelROIFilterStartYSet.PROC PP")
   field(OUTD, "BL99:Det:N1:Det3:PixelROIFilterSizeYSet.PROC PP")
#   field(OUTE, "BL99:Det:N1:Det3:PixelSizeXSet.PROC PP")
}

################################################################
# Monitor the TOF:ROI:1 values and use them for the TOF ROI filter
# records above. Take into account the ROI binning that may be used.

record(calcout, "BL99:Det:N1:Det3:TOFROIFilterStartSet")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:1:MinX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det3:TOFROIFilterStart.VAL PP")
   field(PINI, "YES")
}
record(calcout, "BL99:Det:N1:Det3:TOFROIFilterSizeSet")
{
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:1:SizeX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det3:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det3:TOFROIFilterSize.VAL PP")
   field(PINI, "YES")
}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det3:TOFROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det3:TOFROIFilterStartSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det3:TOFROIFilterSizeSet.PROC PP")
}

################################################################
# Trigger some records at startup in IOC script

record(dfanout, "BL99:Det:N1:Det3:StartupProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det3:PixelMapFile.PROC PP")
   field(OUTB, "BL99:Det:N1:Det3:PixelROIFilterProc.PROC PP")
   field(OUTC, "BL99:Det:N1:Det3:TOFROIFilterProc.PROC PP")
}


#################################################################
# Provide a parameter to reset the array for the TOF spectrum
# This is useful when moving an ROI around on the X/Y plot, when that
# ROI is filtering the TOF spectrum data during an acqusition. 
# Providing we are not using the TOF spectrum for a counting criteria, 
# this can useful to examine Bragg reflections.
#################################################################

# ///
# /// Reset the TOF spectrum array for detector 3
# ///
record(bo, "BL99:Det:N1:Det3:ResetTOFArray")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,3,5)ADNED_DET_TOF_ARRAY_RESET")
}




#####################################################################
#
# areaDetector nED client template file. This should be included by the
# top level template file. It defines the records that are specific to
# a single detector.
#
# Matt Pearson
# Sept 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# TOFSIZE - The maximum size of the TOF spectrum (eg. 160000)
# TOFXSIZE - The size of the waveform for the DETX TOF spectrum
#
#####################################################################

# ///
# /// Set the description name for this detector
# ///
record(stringout, "BL99:Det:N1:Det4:Description")
{
   field(DESC, "Description")
   field(VAL, " ")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}


#####################################################################
# Set pixel ID ranges for this detector

# ///
# /// Set the start of the pixel range for this detector DET=4
# ///
record(longout, "BL99:Det:N1:Det4:PixelNumStart")
{
   field(DESC, "Pixel range start DET4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the start of the pixel range for this detector DET=4
# ///
record(longin, "BL99:Det:N1:Det4:PixelNumStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_START")
   field(SCAN, "I/O Intr")
}


# ///
# /// Set the end of the pixel range for this detector DET=4
# ///
record(longout, "BL99:Det:N1:Det4:PixelNumEnd")
{
   field(DESC, "Pixel range end DET4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_END")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the end of the pixel range for this detector DET=4
# ///
record(longin, "BL99:Det:N1:Det4:PixelNumEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the size of the pixel range for this detector DET=4
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longout, "BL99:Det:N1:Det4:PixelNumSize")
{
   field(DESC, "Pixel range size DET4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the size of the pixel range for this detector DET=4
# /// This may be bigger than the pixel ID range if there are gaps in the detector.
# ///
record(longin, "BL99:Det:N1:Det4:PixelNumSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_NUM_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the number of time-of-flight bins for this detector DET=4
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longout, "BL99:Det:N1:Det4:TOFNumBins")
{
   field(DESC, "Number of TOF bins DET4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_NUM_BINS")
   field(VAL, "1")
   field(DRVL, "1")
   field(DRVH, "160000")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Get the number of time-of-flight bins for this detector DET=4
# /// This is only used if we are plotting X or Y v TOF. It is not used 
# /// for the TOF integration, only the pixel 2-D plots
# ///
record(longin, "BL99:Det:N1:Det4:TOFNumBins_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_NUM_BINS")
   field(SCAN, "I/O Intr")
}

# ///
# /// Information PV for the X or Y or Pixel ID / TOF plots to show
# /// how large a bin is in milliseconds.
# /// Bin Size in ms = (Max size / #Bins) * (Size of one bin in ms)
# /// For example: 160000 / 160 * 0.0001 = 0.1ms 
# ///
record(calc, "BL99:Det:N1:Det4:XYTOFBinSize")
{
   field(DESC, "2D Plot TOF Bin Size")
   field(INPA, "BL99:Det:N1:Det4:TOFNumBins_RBV CP MS")
   field(INPB, "160000")
   field(CALC, "(B/A)*0.0001")
   field(PREC, "2")
   field(EGU, "ms")
}

# ///
# /// Choose the type of 2-D plot. The standard plot is integrating 
# /// pixel ID in X/Y space. We can also do X/TOF, Y/TOF and PixelID/TOF, providing
# /// the TOFNumBins and PixelNumSize params have been set appropriately.
# ///
record(mbbo, "BL99:Det:N1:Det4:2DType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixeID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the 2-D plot type (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det4:2DType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_2D_TYPE")
   field(ZRST, "X/Y")
   field(ZRVL, "0")
   field(ONST, "X/TOF")
   field(ONVL, "1")
   field(TWST, "Y/TOF")
   field(TWVL, "2")
   field(THST, "PixelID/TOF")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}

#####################################################################
# These records are read only and are used to feed back the NDArray 
# index values for this detector. This will be required for the 
# plugins that extract the detector specific data.

# ///
# /// The NDArray detector data index start for DET=4
# ///
record(longin, "BL99:Det:N1:Det4:NDArrayStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_NDARRAY_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index end for DET=4
# ///
record(longin, "BL99:Det:N1:Det4:NDArrayEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_NDARRAY_END")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray detector data index size for DET=4
# ///
record(longin, "BL99:Det:N1:Det4:NDArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_NDARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index start for DET=4
# ///
record(longin, "BL99:Det:N1:Det4:NDArrayTOFStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_NDARRAY_TOF_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// The NDArray TOF index end for DET=4
# ///
record(longin, "BL99:Det:N1:Det4:NDArrayTOFEnd_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_NDARRAY_TOF_END")
   field(SCAN, "I/O Intr")
}

#####################################################################
# Detector specific data feedback

# ///
# /// Event rate
# ///
record(longin, "BL99:Det:N1:Det4:EventRate_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_EVENT_RATE")
   field(SCAN, "I/O Intr")
   field(EGU, "e/s")
}

# ///
# /// Total events since last start
# ///
record(ai, "BL99:Det:N1:Det4:EventTotal_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_EVENT_TOTAL")
   field(SCAN, "I/O Intr")
   field(EGU, "Events")
   field(PREC, "3")
}

#####################################################################
# Define a TOF ROI to pre-filter the events for this detector DET=4
# This is automatically disabled if the pixel ROI filter is enabled (and visa-versa)

# ///
# /// Set the TOF ROI start for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:TOFROIFilterStart")
{
   field(DESC, "Pre TOF ROI Start")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_START")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI start for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:TOFROIFilterStart_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_START")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the TOF ROI size for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:TOFROIFilterSize")
{
   field(DESC, "Pre TOF ROI Size")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_SIZE")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# ///  Read the TOF ROI size for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:TOFROIFilterSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_SIZE")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 4
# ///
record(bo, "BL99:Det:N1:Det4:TOFROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this TOF ROI pre-filter for DET 4 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det4:TOFROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# TOF Transformation File & Control


#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 0
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile0")
{
    field(DESC, "TOF Trans File0")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 0 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile0_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE0")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 0
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt0")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT0")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 0 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt0_RBV")
{
   field(DESC, "TOF Trans Int0")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT0")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 0
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat0")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 0 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat0_RBV")
{
   field(DESC, "TOF Trans Float0")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT0")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 1
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile1")
{
    field(DESC, "TOF Trans File1")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 1 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile1_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE1")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 1
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt1")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT1")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 1 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt1_RBV")
{
   field(DESC, "TOF Trans Int1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT1")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 1
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat1")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 1 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat1_RBV")
{
   field(DESC, "TOF Trans Float1")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT1")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 2
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile2")
{
    field(DESC, "TOF Trans File2")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 2 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile2_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE2")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 2
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt2")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT2")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 2 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt2_RBV")
{
   field(DESC, "TOF Trans Int2")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT2")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 2
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat2")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 2 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat2_RBV")
{
   field(DESC, "TOF Trans Float2")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT2")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 3
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile3")
{
    field(DESC, "TOF Trans File3")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 3 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile3_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE3")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 3
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt3")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT3")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 3 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt3_RBV")
{
   field(DESC, "TOF Trans Int3")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT3")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 3
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat3")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 3 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat3_RBV")
{
   field(DESC, "TOF Trans Float3")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT3")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 4
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile4")
{
    field(DESC, "TOF Trans File4")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 4 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile4_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE4")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 4
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt4")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT4")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 4 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt4_RBV")
{
   field(DESC, "TOF Trans Int4")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT4")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 4
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat4")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 4 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat4_RBV")
{
   field(DESC, "TOF Trans Float4")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT4")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





#####################################################################
#
# This file has records for each detector that are used by the 
# ADnEDTransform support. Multiple instances of this template can
# be made to support multiple arrays & parameters for use in ADnEDTransform.
# This file should be included in ADnEDDetector.template. 
#
# Matt Pearson
# Apr 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# TIMEOUT - Asyn timeout
# INDEX - The ADnEDTransform index number (0-based, up to ADNED_MAX_TRANSFORM_PARAMS-1)
#
#####################################################################

# ///
# /// TOF Transformation File for array index 5
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile5")
{
    field(DESC, "TOF Trans File5")
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation File for array index 5 Readback
# ///
record(waveform, "BL99:Det:N1:Det4:TOFTransFile5_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FILE5")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Integer index 5
# ///
record(longout, "BL99:Det:N1:Det4:TOFTransInt5")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT5")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Integer index 5 readback
# ///
record(longin, "BL99:Det:N1:Det4:TOFTransInt5_RBV")
{
   field(DESC, "TOF Trans Int5")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_INT5")
   field(SCAN, "I/O Intr")
}

# ///
# /// TOF Transformation Float64 index 5
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransFloat5")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(VAL, "0.0")
   field(PINI, "YES")
   field(PREC, "4")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE") 
}

# ///
# /// TOF Transformation Float64 index 5 readback
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransFloat5_RBV")
{
   field(DESC, "TOF Trans Float5")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_FLOAT5")
   field(SCAN, "I/O Intr")
   field(PREC, "4")	
}





# ///
# /// To aid debug, print TOF Transformation details to IOC shell
# ///
record(bo, "BL99:Det:N1:Det4:TOFTransPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_PRINT")
}

# ///
# /// Control debug param for this detector
# ///
record(bo, "BL99:Det:N1:Det4:TOFTransDebug")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(VAL, "0")
    field(PINI, "YES")
    field(ASG, "BEAMLINE")
}
record(bi, "BL99:Det:N1:Det4:TOFTransDebug_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_DEBUG")
    field(ZNAM, "Off")
    field(ONAM, "On")
    field(SCAN, "I/O Intr")
}

# ///
# /// Choose the type of TOF transformation applied. This list
# /// should match what is defined in the ADnEDTransform class.
# /// Default is None, which also disables the scale factor and offset.
# ///
record(mbbo, "BL99:Det:N1:Det4:TOFTransType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback the TOF transformation (readback only)
# ///
record(mbbi, "BL99:Det:N1:Det4:TOFTransType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_TYPE")
   field(ZRST, "None")
   field(ZRVL, "0")
   field(ONST, "Static D Space")
   field(ONVL, "1")
   field(TWST, "Dynamic D Space")
   field(TWVL, "2")
   field(THST, "Delta E")
   field(THVL, "3")
   field(VAL,  "0")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Scale factor and offset (in horizontal direction) for TOF spectrum
# This can be useful for binning the TOF spectrum, particulary after
# a TOF transformation. These records have no effect if there is
# no transformation enabled or loaded.

# ///
# /// Set the TOF offset
# /// For no offset, set this to 0
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransOffset")
{
   field(DESC, "TOF Filter Offset")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(VAL, "0")
   field(PREC, "2")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF offset
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransOffset_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_OFFSET")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

# ///
# /// Set the TOF scale factor
# /// Set this to 1 for no scaling.
# /// If no transformation is done, this has no effect.
# ///
record(ao, "BL99:Det:N1:Det4:TOFTransScale")
{
   field(DESC, "TOF Filter Scale")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_SCALE")
   field(VAL, "1")
   field(PREC, "2")	
   field(PINI, "YES")
   info(autosaveFields, "VAL")
}

# ///
# /// Readback of the TOF scale factor
# ///
record(ai, "BL99:Det:N1:Det4:TOFTransScale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_TOF_TRANS_SCALE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")	
}

#####################################################################
# Pixel mapping file & control

# ///
# /// Pixel Map File
# /// This is loaded into an array, which is used to map the pixel
# /// ID to a new location in the detector array. 
# ///
record(waveform, "BL99:Det:N1:Det4:PixelMapFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    info(autosaveFields, "VAL")
    field(ASG, "BEAMLINE")
}

# ///
# /// Pixel Map File Readback
# ///
record(waveform, "BL99:Det:N1:Det4:PixelMapFile_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_MAP_FILE")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ///
# /// To aid debug, print pixel map array to IOC shell
# ///
record(bo, "BL99:Det:N1:Det4:PixelMapPrint")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_MAP_PRINT")
}

# ///
# /// Enable pixel mapping for DET 4
# ///
record(bo, "BL99:Det:N1:Det4:PixelMapEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

# ///
# /// Enable pixel mapping for DET 4 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det4:PixelMapEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_MAP_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

#####################################################################
# Define a Pixel X/Y ROI to pre-filter the events for this detector DET=4
# This is automatically disabled if the TOF ROI filter is enabled (and visa-versa)
# The filter is applied after the pixel mapping is done. If there is no 
# pixel mapping enabled, or defined, then the ROI filter is still applied (but
# it might not make much sense).

# ///
# /// Set the Pixel XY ROI start X for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:PixelROIFilterStartX")
{
   field(DESC, "Pre Pixel ROI Start X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_START_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start X for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:PixelROIFilterStartX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_START_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size X for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:PixelROIFilterSizeX")
{
   field(DESC, "Pre Pixel ROI Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size X for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:PixelROIFilterSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI start Y for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:PixelROIFilterStartY")
{
   field(DESC, "Pre Pixel ROI Start Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI start Y for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:PixelROIFilterStartY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_START_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the Pixel XY ROI size Y for DET 4
# ///
record(longout, "BL99:Det:N1:Det4:PixelROIFilterSizeY")
{
   field(DESC, "Pre Pixel ROI Size Y")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Read the Pixel XY ROI size Y for DET 4
# ///
record(longin, "BL99:Det:N1:Det4:PixelROIFilterSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_SIZE_Y")
   field(SCAN, "I/O Intr")
}

# ///
# /// Set the pixel ID X size for DET 4. This should match
# /// the value used for the initial ROI plugin that converts
# /// from 1-D to 2-D, but I need the value here to apply the ROI filter.
# /// This is not the ROI X size, but the detector X size.
# ///
# /// For 2-D plots other than X/Y then this parameter does not
# /// match the initial ROI plugin size. This should be the number
# /// of pixels in the X dimension on the detector. For X/TOF and Y/TOF
# /// plots the X size of the resulting array is different from the 
# /// detector X size.
# ///
record(longout, "BL99:Det:N1:Det4:PixelSizeX")
{
   field(DESC, "Pixel Size X")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_SIZE_X")
   field(VAL, "1")
   field(LOPR, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

# ///
# /// Read the pixel ID X size for DET 4
# /// This is not the ROI X size, but the detector X size.
# ///
record(longin, "BL99:Det:N1:Det4:PixelSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_SIZE_X")
   field(SCAN, "I/O Intr")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 4
# ///
record(bo, "BL99:Det:N1:Det4:PixelROIFilterEnable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
    field(ASG, "ALWAYS")
}

# ///
# /// Enable the use of this Pixel XY ROI pre-filter for DET 4 (Readback only)
# ///
record(bi, "BL99:Det:N1:Det4:PixelROIFilterEnable_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1,4,5)ADNED_DET_PIXEL_ROI_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}


#####################################################################
# Reset the Pixel and TOF ROIStat plugins
#####################################################################

# ///
# /// Reset the pixel and TOF ROIStat plugins. Need to know how many
# /// plugins we have instantiated in ADnEDDetectorPixelPlugin and 
# /// ADnEDDetectorTOFPlugin.
# ///
record(dfanout, "BL99:Det:N1:Det4:ResetROIStat")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det4:XY:ROI:ResetAll PP")
   field(OUTB, "BL99:Det:N1:Det4:TOF:ROI:ResetAll PP")
}


#####################################################################
# Records to define the scale for the X axis plot for TOF/dE/d-space etc

record(ai, "BL99:Det:N1:Det4:TOF:XAxis_Start")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(longin, "BL99:Det:N1:Det4:TOF:XAxis_Size")
{
   field(PINI, "YES")
   field(VAL, "16000")
   field(HHSV, "MAJOR")
   info(autosaveFields, "VAL")	
}

record(calcout, "BL99:Det:N1:Det4:TOF:XAxis_SizeHIHI")
{
   field(PINI, "YES")
   field(INPA, "16000")
   field(INPB, "1")
   field(CALC, "A+1")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det4:TOF:XAxis_Size.HIHI PP")
}

record(ai, "BL99:Det:N1:Det4:TOF:XAxis_Bin")
{
   field(PINI, "YES")
   field(VAL, "1.0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

record(ai, "BL99:Det:N1:Det4:TOF:XAxis_End")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "4")
   info(autosaveFields, "VAL")	
}

# ///
# /// INPA - Start value
# /// INPB - Size of the desired scale array (must be <=NOVA)
# /// INPC - Bin size
# /// NOVA - Max size of the output array. This should match the max size of
# ///        of the TOF waveform.
# ///
record(aSub, "BL99:Det:N1:Det4:TOF:XAxis")
{
   field(INAM, "ADnEDAxisInit")
   field(SNAM, "ADnEDAxisProcess")
   field(PREC, "4")
   field(PINI, "YES")
   field(INPA, "BL99:Det:N1:Det4:TOF:XAxis_Start")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_Size")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Bin")
   field(FTA, "DOUBLE")
   field(FTB, "LONG")
   field(FTC, "DOUBLE")
   field(FTVA, "DOUBLE")
   field(NOVA, "16000")
}

#####################################################################
# Monitor initial ROI binning parameter, and optionally 
# do an automatic X-axis generate for the TOF plot.

# ///
# /// Auto scale the TOF X-Axis plot waveform
# ///
record(bi, "BL99:Det:N1:Det4:TOF:XAxis_Auto")
{
   field(DESC, "XAxis Auto Scale")
   field(PINI, "YES")
   field(VAL, "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")	
}

# ///
# /// Process BL99:Det:N1:Det4:TOF:XAxis if XAxis_Auto is enabled and the TOF binning changes
# ///
record(calcout, "BL99:Det:N1:Det4:TOF:XAxis_Auto_Proc")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:XAxis_Auto CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:BinX CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPD, "160000")
   field(CALC, "A=1")
   field(OOPT, "When Non-zero")
   field(DOPT, "Use OCAL")
   field(OCAL, "D/B")
   field(OUT, "BL99:Det:N1:Det4:TOF:XAxis_Size PP")
   field(FLNK, "BL99:Det:N1:Det4:TOF:XAxis_Auto_Proc2")
}
record(calcout, "BL99:Det:N1:Det4:TOF:XAxis_Auto_Proc2")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:XAxis_End")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_Size")
   field(CALC, "A/B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det4:TOF:XAxis_Bin PP")
   field(FLNK, "BL99:Det:N1:Det4:TOF:XAxis")
}


#####################################################################
# Provide records to convert high level ROI start and size to bins



#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:0:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:0:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:0:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:0:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:0:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:0:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:0:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:0:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:1:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:1:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:1:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:1:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:1:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:1:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:1:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:1:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:2:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:2:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:2:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:2:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:2:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:2:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:2:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:2:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:3:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:3:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:3:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:3:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:3:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:3:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:3:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:3:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:4:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:4:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:4:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:4:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:4:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:4:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:4:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:4:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:5:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:5:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:5:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:5:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:5:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:5:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:5:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:5:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:6:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:6:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:6:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:6:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:6:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:6:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:6:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:6:SizeX PP")
}







#####################################################################
#
# areaDetector nED client template file. This should be included by the
# ADnEDDetector.template file, for each TOF ROI being used. 
# It defines new high level ROI records that present different units.
#
# Matt Pearson
# March 15
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# DET - Asyn address (used to identify a detector, 1-based)
# ROI - ROI number
# SIZE1 - PV for the size of the plot in science units (eg 16ms)
# SIZE2 - PV for the size of the array after binning (eg. 160000 bins)
# SIZE3 - PV for the start of the plot in science units (eg. 2ms, if we plot from 2 to 16)
# TIMEOUT - Asyn timeout
#
#####################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:Min")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:7:CalcMin")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:Size")
{
   field(PINI, "YES")
   field(VAL, "0")
   field(PREC, "2")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:7:CalcSize")
   info(autosaveFields, "VAL")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:7:CalcMin")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:7:Min CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(INPD, "BL99:Det:N1:Det4:TOF:XAxis_Start CP")
   field(CALC, "(((A-D)/B)*C)")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:7:MinX PP")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:7:CalcSize")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:7:Size CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:XAxis_End CP")
   field(INPC, "BL99:Det:N1:Det4:TOF:XAxis_Size CP")
   field(CALC, "(A/B)*C")
   field(OUT, "BL99:Det:N1:Det4:TOF:ROI:7:SizeX PP")
}







#####################################################################
# Add ROI rate calculations for TOF and pixel XY ROIs


# ///
# /// Count rate in Det=4, Type=TOF, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=TOF, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det4:TOF:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



# ///
# /// Count rate in Det=4, Type=XY, ROI=0 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:0:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:0:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:0:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:0:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=1 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:1:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:1:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:1:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:1:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=2 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:2:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:2:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:2:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:2:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=3 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:3:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:3:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:3:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:3:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=4 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:4:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:4:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:4:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:4:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=5 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:5:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:5:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:5:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:5:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=6 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:6:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:6:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:6:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:6:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}


# ///
# /// Count rate in Det=4, Type=XY, ROI=7 
# ///
record(calc, "BL99:Det:N1:Det4:XY:ROI:7:Rate")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:7:Rate.LB NPP NMS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:7:Total_RBV NPP NMS")
    field(INPC, "1.0")                              
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:7:Rate.VAL NPP NMS")
    field(INPE, "0.0")             
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "0")
    field(EGU,  "e/s")
    field(SCAN, "1 second")
}



################################################################
# Monitor the XY:ROI:1 values and use them for the X/Y ROI filter
# records above. 

record(dfanout, "BL99:Det:N1:Det4:PixelROIFilterStartXSet")
{
   field(DOL, "BL99:Det:N1:Det4:XY:ROI:1:MinX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det4:PixelROIFilterStartX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det4:PixelROIFilterSizeXSet")
{
   field(DOL, "BL99:Det:N1:Det4:XY:ROI:1:SizeX_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det4:PixelROIFilterSizeX.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det4:PixelROIFilterStartYSet")
{
   field(DOL, "BL99:Det:N1:Det4:XY:ROI:1:MinY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det4:PixelROIFilterStartY.VAL PP")
   field(PINI, "YES")
}
record(dfanout, "BL99:Det:N1:Det4:PixelROIFilterSizeYSet")
{
   field(DOL, "BL99:Det:N1:Det4:XY:ROI:1:SizeY_RBV.VAL CP")
   field(OMSL, "closed_loop")
   field(OUTA, "BL99:Det:N1:Det4:PixelROIFilterSizeY.VAL PP")
   field(PINI, "YES")
}
# and set the pixel X size (the size of the detector in the X direction)
# 2015/10/19 I commented this out because XY:Size1 cannot be used for the X/TOF or Y/TOF
# type 2-D plots. I need to set this manually on the setup screen.
#record(dfanout, "BL99:Det:N1:Det4:PixelSizeXSet")
#{
#   field(DOL, "BL99:Det:N1:Det4:XY:Size1_RBV.VAL CP")
#   field(OMSL, "closed_loop")
#   field(OUTA, "BL99:Det:N1:Det4:PixelSizeX.VAL PP")
#   field(PINI, "YES")
#}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det4:PixelROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det4:PixelROIFilterStartXSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det4:PixelROIFilterSizeXSet.PROC PP")
   field(OUTC, "BL99:Det:N1:Det4:PixelROIFilterStartYSet.PROC PP")
   field(OUTD, "BL99:Det:N1:Det4:PixelROIFilterSizeYSet.PROC PP")
#   field(OUTE, "BL99:Det:N1:Det4:PixelSizeXSet.PROC PP")
}

################################################################
# Monitor the TOF:ROI:1 values and use them for the TOF ROI filter
# records above. Take into account the ROI binning that may be used.

record(calcout, "BL99:Det:N1:Det4:TOFROIFilterStartSet")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:1:MinX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det4:TOFROIFilterStart.VAL PP")
   field(PINI, "YES")
}
record(calcout, "BL99:Det:N1:Det4:TOFROIFilterSizeSet")
{
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:1:SizeX_RBV.VAL CP")
   field(INPB, "BL99:Det:N1:Det4:TOF:BinX_RBV.VAL CP")
   field(CALC, "A*B")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Det4:TOFROIFilterSize.VAL PP")
   field(PINI, "YES")
}

# Not sure why but the above records seem to require an additonal process at startup
# This is triggered in IOC startup script.
record(dfanout, "BL99:Det:N1:Det4:TOFROIFilterProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det4:TOFROIFilterStartSet.PROC PP")
   field(OUTB, "BL99:Det:N1:Det4:TOFROIFilterSizeSet.PROC PP")
}

################################################################
# Trigger some records at startup in IOC script

record(dfanout, "BL99:Det:N1:Det4:StartupProc")
{
   field(VAL, "1")
   field(OUTA, "BL99:Det:N1:Det4:PixelMapFile.PROC PP")
   field(OUTB, "BL99:Det:N1:Det4:PixelROIFilterProc.PROC PP")
   field(OUTC, "BL99:Det:N1:Det4:TOFROIFilterProc.PROC PP")
}


#################################################################
# Provide a parameter to reset the array for the TOF spectrum
# This is useful when moving an ROI around on the X/Y plot, when that
# ROI is filtering the TOF spectrum data during an acqusition. 
# Providing we are not using the TOF spectrum for a counting criteria, 
# this can useful to examine Bragg reflections.
#################################################################

# ///
# /// Reset the TOF spectrum array for detector 4
# ///
record(bo, "BL99:Det:N1:Det4:ResetTOFArray")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1,4,5)ADNED_DET_TOF_ARRAY_RESET")
}



#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin ROIs for a single detector. It copies the NDArray
# index numbers published by the main driver into the ROI Min and End records.
# This works for both a detector and beam monitor. It assumes there is
# a ROI plugin extracting the block of data for this detector for
# both the pixel and the TOF data (2 ROI plugins).
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
#
#####################################################################

# ///
# /// Copy NDArray TOF Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det1:ConfigTOFStart")
{
  field(INPA, "BL99:Det:N1:Det1:NDArrayTOFStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det1:TOF:MinX PP")
  field(FLNK, "BL99:Det:N1:Det1:ConfigTOFSize")
}

# ///
# /// Copy NDArray TOF Size to EndX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det1:ConfigTOFSize")
{
  field(INPA, "BL99:Det:N1:TOFMax_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det1:TOF:SizeX PP")
}

# ///
# /// Copy NDArray Pixel Data Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det1:ConfigXYStart")
{
  field(INPA, "BL99:Det:N1:Det1:NDArrayStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det1:XY:Min0 PP")
  field(FLNK, "BL99:Det:N1:Det1:ConfigXYSize")
}

# ///
# /// Copy NDArray Pixel Data Size to SizeX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det1:ConfigXYSize")
{
  field(INPA, "BL99:Det:N1:Det1:NDArrayStart_RBV")
  field(INPB, "BL99:Det:N1:Det1:NDArrayEnd_RBV")
  field(CALC, "(B-A)+1")
  field(OUT, "BL99:Det:N1:Det1:XY:Size0 PP")
}



#####################################################################
# Records to provide scale and offset for auto image max scaling using ROI:0

# ///
# /// The scale factor to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det1:XY:Scale:Scale")
{
   field(VAL, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// The offset to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det1:XY:Scale:Offset")
{
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Calculate the image max using the mean intensity from the auto scaling stats plugin
# ///
record(calc, "BL99:Det:N1:Det1:XY:Scale:Result")
{
   field(INPA, "BL99:Det:N1:Det1:XY:ROI:0:MeanValue_RBV CP MS")
   field(INPB, "BL99:Det:N1:Det1:XY:Scale:Scale.VAL CP MS")
   field(INPC, "BL99:Det:N1:Det1:XY:Scale:Offset.VAL CP MS")
   field(CALC, "FLOOR((A*B)+C)")
}

# ///
# /// Default max value for the manual scale slider and image max.
# ///
record(longout, "BL99:Det:N1:Det1:XY:Scale:ManualMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Slide max value for the manual control.
# ///
record(longout, "BL99:Det:N1:Det1:XY:Scale:SlideMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}




#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin for a single detector for the TOF spectrums. 
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# NELEMENTS - Max size of TOF spectrum
#
#####################################################################


# TOF Initial ROI (to extract the 1-D TOF spectrum)
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:AsynIO")
{
    field(PORT, N1.DET1.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROI.template
# Database for ND ROIs
# Mark Rivers
# April 22, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:AsynIO")
{
    field(PORT, N1.DET1.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including binning, region start and size                       # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:BinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:BinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:MinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_MIN")
   field(LOPR, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:MinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:SizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:SizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:AutoSizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:AutoSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:AutoSizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:AutoSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:AutoSizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:AutoSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:MaxSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:ReverseZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ReverseZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:EnableX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM0_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM0_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:EnableY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM1_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM1_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det1:TOF:EnableZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)DIM2_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)DIM2_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the scaling of the data.  Useful when    #
#  binning or converting data types                               # 
###################################################################

record(bo, "BL99:Det:N1:Det1:TOF:EnableScale")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)ENABLE_SCALE")
   field(VAL,  "0")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:EnableScale_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ENABLE_SCALE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:Scale")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)SCALE_VALUE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:Scale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)SCALE_VALUE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det1:TOF:MaxX")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:MaxSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det1:TOF:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det1:TOF:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det1:TOF:MaxX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det1:TOF:MinX.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det1:TOF:SizeX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det1:TOF:MaxY")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:MaxSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det1:TOF:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det1:TOF:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det1:TOF:MaxY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det1:TOF:MinY.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det1:TOF:SizeY.HOPR NPP")
}



# TOF Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:Array:AsynIO")
{
    field(PORT, N1.DET1.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:Array:AsynIO")
{
    field(PORT, N1.DET1.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det1:TOF:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "16000")
    field(SCAN, "I/O Intr")
}

# Normal TOF ROIs amd Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET1.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET1.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det1:TOF:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det1:TOF:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det1:TOF:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det1:TOF:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det1:TOF:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "$(NCHANS,undefined)")
   field(DRVH, "$(NCHANS,undefined)")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:TOF:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:TOF:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:TOF:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:TOF:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:TOF:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:TOF:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.TOF.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for TOF XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:TOF:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:TOF:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugins for the pixel XY array for a single detector.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
# XSIZE - The X size of the XY plot (required for NDStats.template)
# YSIZE - The Y size of the XY plot (required for NDStats.template)
#
#####################################################################


# Pixel Initial ROI to convert from 1-D to 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:AsynIO")
{
    field(PORT, N1.DET1.XY)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#####################################################################
#
# areaDetector nED client template file. This is the template
# for the ADnEDPixelROI plugin. This was based on the original
# ROI plugin template, but has had some things removed and
# things added to deal with 1-D to 2-D conversion.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# ADDR - Asyn address (set to zero)
# TIMEOUT - Asyn timeout
# 
#
#####################################################################

###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################


record(longout, "BL99:Det:N1:Det1:XY:Min0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Min0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Min1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Min1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Min2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM2_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Min2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Size0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Size0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Size1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Size1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Size2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det1:XY:Size2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:MaxSize0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:MaxSize1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:MaxSize2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(mbbi, "BL99:Det:N1:Det1:XY:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

#record(longin, "BL99:Det:N1:Det1:XY:MaxX")
#{
#    field(INP,  "BL99:Det:N1:Det1:XY:MaxSizeX_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det1:XY:SetXHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det1:XY:SetXHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det1:XY:MaxX NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det1:XY:MinX.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det1:XY:SizeX.HOPR NPP")
#}

#record(longin, "BL99:Det:N1:Det1:XY:MaxY")
#{
#    field(INP,  "BL99:Det:N1:Det1:XY:MaxSizeY_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det1:XY:SetYHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det1:XY:SetYHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det1:XY:MaxY NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det1:XY:MinY.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det1:XY:SizeY.HOPR NPP")
#}



# Pixel X/Y Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:Array:AsynIO")
{
    field(PORT, N1.DET1.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:Array:AsynIO")
{
    field(PORT, N1.DET1.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det1:XY:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ROI and Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:ROI:AsynIO")
{
    field(PORT, N1.DET1.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:ROI:AsynIO")
{
    field(PORT, N1.DET1.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det1:XY:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det1:XY:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det1:XY:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det1:XY:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det1:XY:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "$(NCHANS,undefined)")
   field(DRVH, "$(NCHANS,undefined)")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det1:XY:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "$(NCHANS,undefined)")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


# Single Stats Plugin on entire 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:Stat:AsynIO")
{
    field(PORT, N1.DET1.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStats.template

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det1:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det1:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det1:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det1:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det1:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det1:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det1:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det1:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det1:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det1:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET1.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det1:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det1:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det1:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det1:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det1:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det1:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det1:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det1:XY:Stat:AsynIO")
{
    field(PORT, N1.DET1.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records contain the basic statistics                     #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ComputeStatistics")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(VAL,  "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ComputeStatistics_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)BGD_WIDTH")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)BGD_WIDTH")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MinValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MaxValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MeanValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MEAN_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:SigmaValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMA_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:Sigma_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMA_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:Total")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)TOTAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TOTAL")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:Net")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)NET")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)NET")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MinX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_X")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MinX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MinY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_Y")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MinY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MaxX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_X")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MaxX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:MaxY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_Y")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:MaxY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)MAX_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether centroid statistics are computed #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ComputeCentroid")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_CENTROID")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ComputeCentroid_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_CENTROID")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain the centroid statistics                  #
###################################################################
record(ao, "BL99:Det:N1:Det1:XY:Stat:CentroidThreshold")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}
record(ai, "BL99:Det:N1:Det1:XY:Stat:CentroidThreshold_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:CentroidX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROIDX_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:CentroidX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROIDX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:CentroidY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROIDY_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:CentroidY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)CENTROIDY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:SigmaX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAX_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:SigmaX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:SigmaY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAY_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:SigmaY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:SigmaXY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAXY_VALUE")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:SigmaXY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)SIGMAXY_VALUE")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det1:XY:Stat:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det1:XY:Stat:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det1:XY:Stat:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det1:XY:Stat:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMinX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MIN_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMinY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MIN_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMaxX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MAX_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMaxY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MAX_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSSigma")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_SIGMA_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSCentroidX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_CENTROIDX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSCentroidY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_CENTROIDY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSSigmaX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_SIGMAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSSigmaY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_SIGMAY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSSigmaXY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_SIGMAXY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)TS_TIMESTAMP_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control profiles                                 #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ComputeProfiles")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_PROFILES")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ComputeProfiles_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_PROFILES")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ProfileSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:ProfileSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:CursorX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)CURSOR_X")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:CursorX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)CURSOR_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:CursorY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)CURSOR_Y")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:CursorY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)CURSOR_Y")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileAverageX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_AVERAGE_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileAverageY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_AVERAGE_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileThresholdX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_THRESHOLD_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileThresholdY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_THRESHOLD_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileCentroidX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_CENTROID_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileCentroidY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_CENTROID_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileCursorX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_CURSOR_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:ProfileCursorY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)PROFILE_CURSOR_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These are used to define the histogram                         #
###################################################################
record(bo, "BL99:Det:N1:Det1:XY:Stat:ComputeHistogram")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det1:XY:Stat:ComputeHistogram_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det1:XY:Stat:HistSize")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_SIZE")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:HistSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_SIZE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:HistMin")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:HistMin_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_MIN")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:HistMax")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_MAX")
   field(VAL,  "255")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:HistMax_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_MAX")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det1:XY:Stat:HistEntropy")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_ENTROPY")
}

record(ai, "BL99:Det:N1:Det1:XY:Stat:HistEntropy_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_ENTROPY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det1:XY:Stat:Histogram_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET1.XY.STAT,0,1)HIST_ARRAY")
   field(FTVL, "DOUBLE")
   field(NELM, "1024")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the cursor      #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det1:XY:Stat:MaxSizeX")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:ProfileSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det1:XY:Stat:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det1:XY:Stat:MaxSizeX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det1:XY:Stat:CursorX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det1:XY:Stat:MaxSizeY")
{
    field(INP,  "BL99:Det:N1:Det1:XY:Stat:ProfileSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det1:XY:Stat:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det1:XY:Stat:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det1:XY:Stat:MaxSizeY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det1:XY:Stat:CursorY.HOPR NPP")
}

###################################################################
#  These records reset the statistics                             #
###################################################################
record(sseq, "BL99:Det:N1:Det1:XY:Stat:Reset")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det1:XY:Stat:MinValue PP MS")    
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det1:XY:Stat:MaxValue PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det1:XY:Stat:MaxValue PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det1:XY:Stat:MeanValue PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det1:XY:Stat:SigmaValue PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det1:XY:Stat:Total PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det1:XY:Stat:Net PP MS")    
   field(DOL8, "0")
   field(DLY8, "0")
   field(LNK8, "BL99:Det:N1:Det1:XY:Stat:MinX PP MS")    
   field(DOL9, "0")
   field(DLY9, "0")
   field(LNK9, "BL99:Det:N1:Det1:XY:Stat:MinY PP MS")    
   field(DOLA, "0")
   field(DLYA, "0")
   field(LNKA, "BL99:Det:N1:Det1:XY:Stat:MaxX PP MS")    
   field(FLNK, "BL99:Det:N1:Det1:XY:Stat:Reset1")   
}

record(sseq, "BL99:Det:N1:Det1:XY:Stat:Reset1")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det1:XY:Stat:MaxY PP MS")
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det1:XY:Stat:CentroidX PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det1:XY:Stat:CentroidY PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det1:XY:Stat:SigmaX PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det1:XY:Stat:SigmaY PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det1:XY:Stat:SigmaXY PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det1:XY:Stat:HistEntropy PP MS")    
}





#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for pixel XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det1:XY:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det1:XY:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin ROIs for a single detector. It copies the NDArray
# index numbers published by the main driver into the ROI Min and End records.
# This works for both a detector and beam monitor. It assumes there is
# a ROI plugin extracting the block of data for this detector for
# both the pixel and the TOF data (2 ROI plugins).
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
#
#####################################################################

# ///
# /// Copy NDArray TOF Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det2:ConfigTOFStart")
{
  field(INPA, "BL99:Det:N1:Det2:NDArrayTOFStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det2:TOF:MinX PP")
  field(FLNK, "BL99:Det:N1:Det2:ConfigTOFSize")
}

# ///
# /// Copy NDArray TOF Size to EndX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det2:ConfigTOFSize")
{
  field(INPA, "BL99:Det:N1:TOFMax_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det2:TOF:SizeX PP")
}

# ///
# /// Copy NDArray Pixel Data Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det2:ConfigXYStart")
{
  field(INPA, "BL99:Det:N1:Det2:NDArrayStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det2:XY:Min0 PP")
  field(FLNK, "BL99:Det:N1:Det2:ConfigXYSize")
}

# ///
# /// Copy NDArray Pixel Data Size to SizeX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det2:ConfigXYSize")
{
  field(INPA, "BL99:Det:N1:Det2:NDArrayStart_RBV")
  field(INPB, "BL99:Det:N1:Det2:NDArrayEnd_RBV")
  field(CALC, "(B-A)+1")
  field(OUT, "BL99:Det:N1:Det2:XY:Size0 PP")
}



#####################################################################
# Records to provide scale and offset for auto image max scaling using ROI:0

# ///
# /// The scale factor to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det2:XY:Scale:Scale")
{
   field(VAL, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// The offset to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det2:XY:Scale:Offset")
{
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Calculate the image max using the mean intensity from the auto scaling stats plugin
# ///
record(calc, "BL99:Det:N1:Det2:XY:Scale:Result")
{
   field(INPA, "BL99:Det:N1:Det2:XY:ROI:0:MeanValue_RBV CP MS")
   field(INPB, "BL99:Det:N1:Det2:XY:Scale:Scale.VAL CP MS")
   field(INPC, "BL99:Det:N1:Det2:XY:Scale:Offset.VAL CP MS")
   field(CALC, "FLOOR((A*B)+C)")
}

# ///
# /// Default max value for the manual scale slider and image max.
# ///
record(longout, "BL99:Det:N1:Det2:XY:Scale:ManualMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Slide max value for the manual control.
# ///
record(longout, "BL99:Det:N1:Det2:XY:Scale:SlideMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}




#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin for a single detector for the TOF spectrums. 
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# NELEMENTS - Max size of TOF spectrum
#
#####################################################################


# TOF Initial ROI (to extract the 1-D TOF spectrum)
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:AsynIO")
{
    field(PORT, N1.DET2.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROI.template
# Database for ND ROIs
# Mark Rivers
# April 22, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:AsynIO")
{
    field(PORT, N1.DET2.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including binning, region start and size                       # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:BinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:BinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:MinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_MIN")
   field(LOPR, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:MinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:SizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:SizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:AutoSizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:AutoSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:AutoSizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:AutoSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:AutoSizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:AutoSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:MaxSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:ReverseZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ReverseZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:EnableX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM0_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM0_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:EnableY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM1_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM1_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det2:TOF:EnableZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)DIM2_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)DIM2_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the scaling of the data.  Useful when    #
#  binning or converting data types                               # 
###################################################################

record(bo, "BL99:Det:N1:Det2:TOF:EnableScale")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)ENABLE_SCALE")
   field(VAL,  "0")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:EnableScale_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ENABLE_SCALE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:Scale")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)SCALE_VALUE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:Scale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)SCALE_VALUE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det2:TOF:MaxX")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:MaxSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det2:TOF:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det2:TOF:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det2:TOF:MaxX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det2:TOF:MinX.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det2:TOF:SizeX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det2:TOF:MaxY")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:MaxSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det2:TOF:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det2:TOF:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det2:TOF:MaxY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det2:TOF:MinY.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det2:TOF:SizeY.HOPR NPP")
}



# TOF Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:Array:AsynIO")
{
    field(PORT, N1.DET2.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:Array:AsynIO")
{
    field(PORT, N1.DET2.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det2:TOF:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "16000")
    field(SCAN, "I/O Intr")
}

# Normal TOF ROIs amd Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET2.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET2.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det2:TOF:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det2:TOF:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det2:TOF:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det2:TOF:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det2:TOF:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:TOF:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:TOF:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:TOF:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:TOF:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:TOF:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:TOF:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.TOF.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for TOF XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:TOF:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:TOF:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugins for the pixel XY array for a single detector.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
# XSIZE - The X size of the XY plot (required for NDStats.template)
# YSIZE - The Y size of the XY plot (required for NDStats.template)
#
#####################################################################


# Pixel Initial ROI to convert from 1-D to 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:AsynIO")
{
    field(PORT, N1.DET2.XY)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#####################################################################
#
# areaDetector nED client template file. This is the template
# for the ADnEDPixelROI plugin. This was based on the original
# ROI plugin template, but has had some things removed and
# things added to deal with 1-D to 2-D conversion.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# ADDR - Asyn address (set to zero)
# TIMEOUT - Asyn timeout
# 
#
#####################################################################

###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################


record(longout, "BL99:Det:N1:Det2:XY:Min0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Min0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Min1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Min1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Min2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM2_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Min2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Size0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Size0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Size1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Size1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Size2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det2:XY:Size2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:MaxSize0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:MaxSize1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:MaxSize2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(mbbi, "BL99:Det:N1:Det2:XY:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

#record(longin, "BL99:Det:N1:Det2:XY:MaxX")
#{
#    field(INP,  "BL99:Det:N1:Det2:XY:MaxSizeX_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det2:XY:SetXHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det2:XY:SetXHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det2:XY:MaxX NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det2:XY:MinX.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det2:XY:SizeX.HOPR NPP")
#}

#record(longin, "BL99:Det:N1:Det2:XY:MaxY")
#{
#    field(INP,  "BL99:Det:N1:Det2:XY:MaxSizeY_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det2:XY:SetYHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det2:XY:SetYHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det2:XY:MaxY NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det2:XY:MinY.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det2:XY:SizeY.HOPR NPP")
#}



# Pixel X/Y Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:Array:AsynIO")
{
    field(PORT, N1.DET2.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:Array:AsynIO")
{
    field(PORT, N1.DET2.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det2:XY:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "1024")
    field(SCAN, "I/O Intr")
}

# ROI and Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:ROI:AsynIO")
{
    field(PORT, N1.DET2.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:ROI:AsynIO")
{
    field(PORT, N1.DET2.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det2:XY:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det2:XY:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det2:XY:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det2:XY:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det2:XY:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det2:XY:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


# Single Stats Plugin on entire 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:Stat:AsynIO")
{
    field(PORT, N1.DET2.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStats.template

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det2:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det2:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det2:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det2:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det2:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det2:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det2:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det2:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det2:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det2:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET2.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det2:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det2:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det2:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det2:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det2:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det2:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det2:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det2:XY:Stat:AsynIO")
{
    field(PORT, N1.DET2.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records contain the basic statistics                     #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ComputeStatistics")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(VAL,  "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ComputeStatistics_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)BGD_WIDTH")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)BGD_WIDTH")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MinValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MaxValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MeanValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MEAN_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:SigmaValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMA_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:Sigma_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMA_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:Total")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)TOTAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TOTAL")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:Net")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)NET")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)NET")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MinX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_X")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MinX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MinY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_Y")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MinY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MaxX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_X")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MaxX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:MaxY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_Y")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:MaxY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)MAX_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether centroid statistics are computed #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ComputeCentroid")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_CENTROID")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ComputeCentroid_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_CENTROID")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain the centroid statistics                  #
###################################################################
record(ao, "BL99:Det:N1:Det2:XY:Stat:CentroidThreshold")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}
record(ai, "BL99:Det:N1:Det2:XY:Stat:CentroidThreshold_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:CentroidX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROIDX_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:CentroidX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROIDX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:CentroidY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROIDY_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:CentroidY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)CENTROIDY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:SigmaX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAX_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:SigmaX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:SigmaY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAY_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:SigmaY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:SigmaXY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAXY_VALUE")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:SigmaXY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)SIGMAXY_VALUE")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det2:XY:Stat:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det2:XY:Stat:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det2:XY:Stat:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det2:XY:Stat:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMinX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MIN_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMinY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MIN_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMaxX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MAX_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMaxY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MAX_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSSigma")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_SIGMA_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSCentroidX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_CENTROIDX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSCentroidY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_CENTROIDY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSSigmaX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_SIGMAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSSigmaY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_SIGMAY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSSigmaXY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_SIGMAXY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)TS_TIMESTAMP_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control profiles                                 #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ComputeProfiles")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_PROFILES")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ComputeProfiles_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_PROFILES")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ProfileSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:ProfileSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:CursorX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)CURSOR_X")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:CursorX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)CURSOR_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:CursorY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)CURSOR_Y")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:CursorY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)CURSOR_Y")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileAverageX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_AVERAGE_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileAverageY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_AVERAGE_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileThresholdX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_THRESHOLD_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileThresholdY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_THRESHOLD_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileCentroidX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_CENTROID_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileCentroidY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_CENTROID_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileCursorX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_CURSOR_X")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:ProfileCursorY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)PROFILE_CURSOR_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These are used to define the histogram                         #
###################################################################
record(bo, "BL99:Det:N1:Det2:XY:Stat:ComputeHistogram")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det2:XY:Stat:ComputeHistogram_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det2:XY:Stat:HistSize")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_SIZE")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:HistSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_SIZE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:HistMin")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:HistMin_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_MIN")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:HistMax")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_MAX")
   field(VAL,  "255")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:HistMax_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_MAX")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det2:XY:Stat:HistEntropy")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_ENTROPY")
}

record(ai, "BL99:Det:N1:Det2:XY:Stat:HistEntropy_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_ENTROPY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det2:XY:Stat:Histogram_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET2.XY.STAT,0,1)HIST_ARRAY")
   field(FTVL, "DOUBLE")
   field(NELM, "1024")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the cursor      #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det2:XY:Stat:MaxSizeX")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:ProfileSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det2:XY:Stat:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det2:XY:Stat:MaxSizeX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det2:XY:Stat:CursorX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det2:XY:Stat:MaxSizeY")
{
    field(INP,  "BL99:Det:N1:Det2:XY:Stat:ProfileSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det2:XY:Stat:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det2:XY:Stat:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det2:XY:Stat:MaxSizeY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det2:XY:Stat:CursorY.HOPR NPP")
}

###################################################################
#  These records reset the statistics                             #
###################################################################
record(sseq, "BL99:Det:N1:Det2:XY:Stat:Reset")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det2:XY:Stat:MinValue PP MS")    
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det2:XY:Stat:MaxValue PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det2:XY:Stat:MaxValue PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det2:XY:Stat:MeanValue PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det2:XY:Stat:SigmaValue PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det2:XY:Stat:Total PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det2:XY:Stat:Net PP MS")    
   field(DOL8, "0")
   field(DLY8, "0")
   field(LNK8, "BL99:Det:N1:Det2:XY:Stat:MinX PP MS")    
   field(DOL9, "0")
   field(DLY9, "0")
   field(LNK9, "BL99:Det:N1:Det2:XY:Stat:MinY PP MS")    
   field(DOLA, "0")
   field(DLYA, "0")
   field(LNKA, "BL99:Det:N1:Det2:XY:Stat:MaxX PP MS")    
   field(FLNK, "BL99:Det:N1:Det2:XY:Stat:Reset1")   
}

record(sseq, "BL99:Det:N1:Det2:XY:Stat:Reset1")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det2:XY:Stat:MaxY PP MS")
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det2:XY:Stat:CentroidX PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det2:XY:Stat:CentroidY PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det2:XY:Stat:SigmaX PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det2:XY:Stat:SigmaY PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det2:XY:Stat:SigmaXY PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det2:XY:Stat:HistEntropy PP MS")    
}





#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for pixel XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det2:XY:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det2:XY:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin ROIs for a single detector. It copies the NDArray
# index numbers published by the main driver into the ROI Min and End records.
# This works for both a detector and beam monitor. It assumes there is
# a ROI plugin extracting the block of data for this detector for
# both the pixel and the TOF data (2 ROI plugins).
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
#
#####################################################################

# ///
# /// Copy NDArray TOF Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det3:ConfigTOFStart")
{
  field(INPA, "BL99:Det:N1:Det3:NDArrayTOFStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det3:TOF:MinX PP")
  field(FLNK, "BL99:Det:N1:Det3:ConfigTOFSize")
}

# ///
# /// Copy NDArray TOF Size to EndX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det3:ConfigTOFSize")
{
  field(INPA, "BL99:Det:N1:TOFMax_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det3:TOF:SizeX PP")
}

# ///
# /// Copy NDArray Pixel Data Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det3:ConfigXYStart")
{
  field(INPA, "BL99:Det:N1:Det3:NDArrayStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det3:XY:Min0 PP")
  field(FLNK, "BL99:Det:N1:Det3:ConfigXYSize")
}

# ///
# /// Copy NDArray Pixel Data Size to SizeX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det3:ConfigXYSize")
{
  field(INPA, "BL99:Det:N1:Det3:NDArrayStart_RBV")
  field(INPB, "BL99:Det:N1:Det3:NDArrayEnd_RBV")
  field(CALC, "(B-A)+1")
  field(OUT, "BL99:Det:N1:Det3:XY:Size0 PP")
}



#####################################################################
# Records to provide scale and offset for auto image max scaling using ROI:0

# ///
# /// The scale factor to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det3:XY:Scale:Scale")
{
   field(VAL, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// The offset to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det3:XY:Scale:Offset")
{
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Calculate the image max using the mean intensity from the auto scaling stats plugin
# ///
record(calc, "BL99:Det:N1:Det3:XY:Scale:Result")
{
   field(INPA, "BL99:Det:N1:Det3:XY:ROI:0:MeanValue_RBV CP MS")
   field(INPB, "BL99:Det:N1:Det3:XY:Scale:Scale.VAL CP MS")
   field(INPC, "BL99:Det:N1:Det3:XY:Scale:Offset.VAL CP MS")
   field(CALC, "FLOOR((A*B)+C)")
}

# ///
# /// Default max value for the manual scale slider and image max.
# ///
record(longout, "BL99:Det:N1:Det3:XY:Scale:ManualMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Slide max value for the manual control.
# ///
record(longout, "BL99:Det:N1:Det3:XY:Scale:SlideMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}




#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin for a single detector for the TOF spectrums. 
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# NELEMENTS - Max size of TOF spectrum
#
#####################################################################


# TOF Initial ROI (to extract the 1-D TOF spectrum)
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:AsynIO")
{
    field(PORT, N1.DET3.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROI.template
# Database for ND ROIs
# Mark Rivers
# April 22, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:AsynIO")
{
    field(PORT, N1.DET3.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including binning, region start and size                       # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:BinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:BinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:MinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_MIN")
   field(LOPR, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:MinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:SizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:SizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:AutoSizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:AutoSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:AutoSizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:AutoSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:AutoSizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:AutoSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:MaxSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:ReverseZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ReverseZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:EnableX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM0_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM0_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:EnableY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM1_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM1_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det3:TOF:EnableZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)DIM2_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)DIM2_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the scaling of the data.  Useful when    #
#  binning or converting data types                               # 
###################################################################

record(bo, "BL99:Det:N1:Det3:TOF:EnableScale")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)ENABLE_SCALE")
   field(VAL,  "0")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:EnableScale_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ENABLE_SCALE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:Scale")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)SCALE_VALUE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:Scale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)SCALE_VALUE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det3:TOF:MaxX")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:MaxSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det3:TOF:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det3:TOF:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det3:TOF:MaxX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det3:TOF:MinX.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det3:TOF:SizeX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det3:TOF:MaxY")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:MaxSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det3:TOF:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det3:TOF:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det3:TOF:MaxY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det3:TOF:MinY.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det3:TOF:SizeY.HOPR NPP")
}



# TOF Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:Array:AsynIO")
{
    field(PORT, N1.DET3.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:Array:AsynIO")
{
    field(PORT, N1.DET3.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det3:TOF:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "16000")
    field(SCAN, "I/O Intr")
}

# Normal TOF ROIs amd Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET3.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET3.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det3:TOF:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det3:TOF:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det3:TOF:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det3:TOF:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det3:TOF:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:TOF:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:TOF:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:TOF:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:TOF:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:TOF:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:TOF:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.TOF.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for TOF XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:TOF:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:TOF:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugins for the pixel XY array for a single detector.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
# XSIZE - The X size of the XY plot (required for NDStats.template)
# YSIZE - The Y size of the XY plot (required for NDStats.template)
#
#####################################################################


# Pixel Initial ROI to convert from 1-D to 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:AsynIO")
{
    field(PORT, N1.DET3.XY)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#####################################################################
#
# areaDetector nED client template file. This is the template
# for the ADnEDPixelROI plugin. This was based on the original
# ROI plugin template, but has had some things removed and
# things added to deal with 1-D to 2-D conversion.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# ADDR - Asyn address (set to zero)
# TIMEOUT - Asyn timeout
# 
#
#####################################################################

###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################


record(longout, "BL99:Det:N1:Det3:XY:Min0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Min0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Min1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Min1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Min2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM2_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Min2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Size0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Size0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Size1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Size1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Size2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det3:XY:Size2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:MaxSize0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:MaxSize1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:MaxSize2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(mbbi, "BL99:Det:N1:Det3:XY:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

#record(longin, "BL99:Det:N1:Det3:XY:MaxX")
#{
#    field(INP,  "BL99:Det:N1:Det3:XY:MaxSizeX_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det3:XY:SetXHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det3:XY:SetXHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det3:XY:MaxX NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det3:XY:MinX.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det3:XY:SizeX.HOPR NPP")
#}

#record(longin, "BL99:Det:N1:Det3:XY:MaxY")
#{
#    field(INP,  "BL99:Det:N1:Det3:XY:MaxSizeY_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det3:XY:SetYHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det3:XY:SetYHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det3:XY:MaxY NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det3:XY:MinY.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det3:XY:SizeY.HOPR NPP")
#}



# Pixel X/Y Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:Array:AsynIO")
{
    field(PORT, N1.DET3.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:Array:AsynIO")
{
    field(PORT, N1.DET3.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det3:XY:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "5120")
    field(SCAN, "I/O Intr")
}

# ROI and Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:ROI:AsynIO")
{
    field(PORT, N1.DET3.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:ROI:AsynIO")
{
    field(PORT, N1.DET3.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det3:XY:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det3:XY:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det3:XY:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det3:XY:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det3:XY:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det3:XY:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


# Single Stats Plugin on entire 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:Stat:AsynIO")
{
    field(PORT, N1.DET3.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStats.template

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det3:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det3:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det3:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det3:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det3:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det3:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det3:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det3:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det3:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det3:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET3.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det3:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det3:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det3:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det3:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det3:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det3:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det3:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det3:XY:Stat:AsynIO")
{
    field(PORT, N1.DET3.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records contain the basic statistics                     #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ComputeStatistics")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(VAL,  "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ComputeStatistics_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)BGD_WIDTH")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)BGD_WIDTH")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MinValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MaxValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MeanValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MEAN_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:SigmaValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMA_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:Sigma_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMA_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:Total")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)TOTAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TOTAL")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:Net")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)NET")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)NET")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MinX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_X")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MinX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MinY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_Y")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MinY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MaxX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_X")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MaxX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:MaxY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_Y")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:MaxY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)MAX_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether centroid statistics are computed #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ComputeCentroid")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_CENTROID")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ComputeCentroid_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_CENTROID")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain the centroid statistics                  #
###################################################################
record(ao, "BL99:Det:N1:Det3:XY:Stat:CentroidThreshold")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}
record(ai, "BL99:Det:N1:Det3:XY:Stat:CentroidThreshold_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:CentroidX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROIDX_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:CentroidX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROIDX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:CentroidY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROIDY_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:CentroidY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)CENTROIDY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:SigmaX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAX_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:SigmaX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:SigmaY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAY_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:SigmaY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:SigmaXY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAXY_VALUE")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:SigmaXY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)SIGMAXY_VALUE")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det3:XY:Stat:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det3:XY:Stat:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det3:XY:Stat:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det3:XY:Stat:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMinX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MIN_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMinY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MIN_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMaxX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MAX_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMaxY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MAX_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSSigma")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_SIGMA_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSCentroidX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_CENTROIDX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSCentroidY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_CENTROIDY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSSigmaX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_SIGMAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSSigmaY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_SIGMAY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSSigmaXY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_SIGMAXY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)TS_TIMESTAMP_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control profiles                                 #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ComputeProfiles")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_PROFILES")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ComputeProfiles_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_PROFILES")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ProfileSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:ProfileSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:CursorX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)CURSOR_X")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:CursorX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)CURSOR_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:CursorY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)CURSOR_Y")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:CursorY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)CURSOR_Y")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileAverageX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_AVERAGE_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileAverageY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_AVERAGE_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileThresholdX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_THRESHOLD_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileThresholdY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_THRESHOLD_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileCentroidX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_CENTROID_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileCentroidY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_CENTROID_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileCursorX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_CURSOR_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:ProfileCursorY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)PROFILE_CURSOR_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These are used to define the histogram                         #
###################################################################
record(bo, "BL99:Det:N1:Det3:XY:Stat:ComputeHistogram")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det3:XY:Stat:ComputeHistogram_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det3:XY:Stat:HistSize")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_SIZE")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:HistSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_SIZE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:HistMin")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:HistMin_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_MIN")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:HistMax")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_MAX")
   field(VAL,  "255")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:HistMax_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_MAX")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det3:XY:Stat:HistEntropy")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_ENTROPY")
}

record(ai, "BL99:Det:N1:Det3:XY:Stat:HistEntropy_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_ENTROPY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det3:XY:Stat:Histogram_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET3.XY.STAT,0,1)HIST_ARRAY")
   field(FTVL, "DOUBLE")
   field(NELM, "5120")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the cursor      #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det3:XY:Stat:MaxSizeX")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:ProfileSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det3:XY:Stat:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det3:XY:Stat:MaxSizeX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det3:XY:Stat:CursorX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det3:XY:Stat:MaxSizeY")
{
    field(INP,  "BL99:Det:N1:Det3:XY:Stat:ProfileSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det3:XY:Stat:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det3:XY:Stat:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det3:XY:Stat:MaxSizeY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det3:XY:Stat:CursorY.HOPR NPP")
}

###################################################################
#  These records reset the statistics                             #
###################################################################
record(sseq, "BL99:Det:N1:Det3:XY:Stat:Reset")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det3:XY:Stat:MinValue PP MS")    
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det3:XY:Stat:MaxValue PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det3:XY:Stat:MaxValue PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det3:XY:Stat:MeanValue PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det3:XY:Stat:SigmaValue PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det3:XY:Stat:Total PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det3:XY:Stat:Net PP MS")    
   field(DOL8, "0")
   field(DLY8, "0")
   field(LNK8, "BL99:Det:N1:Det3:XY:Stat:MinX PP MS")    
   field(DOL9, "0")
   field(DLY9, "0")
   field(LNK9, "BL99:Det:N1:Det3:XY:Stat:MinY PP MS")    
   field(DOLA, "0")
   field(DLYA, "0")
   field(LNKA, "BL99:Det:N1:Det3:XY:Stat:MaxX PP MS")    
   field(FLNK, "BL99:Det:N1:Det3:XY:Stat:Reset1")   
}

record(sseq, "BL99:Det:N1:Det3:XY:Stat:Reset1")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det3:XY:Stat:MaxY PP MS")
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det3:XY:Stat:CentroidX PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det3:XY:Stat:CentroidY PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det3:XY:Stat:SigmaX PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det3:XY:Stat:SigmaY PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det3:XY:Stat:SigmaXY PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det3:XY:Stat:HistEntropy PP MS")    
}





#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for pixel XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det3:XY:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det3:XY:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin ROIs for a single detector. It copies the NDArray
# index numbers published by the main driver into the ROI Min and End records.
# This works for both a detector and beam monitor. It assumes there is
# a ROI plugin extracting the block of data for this detector for
# both the pixel and the TOF data (2 ROI plugins).
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
#
#####################################################################

# ///
# /// Copy NDArray TOF Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det4:ConfigTOFStart")
{
  field(INPA, "BL99:Det:N1:Det4:NDArrayTOFStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det4:TOF:MinX PP")
  field(FLNK, "BL99:Det:N1:Det4:ConfigTOFSize")
}

# ///
# /// Copy NDArray TOF Size to EndX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det4:ConfigTOFSize")
{
  field(INPA, "BL99:Det:N1:TOFMax_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det4:TOF:SizeX PP")
}

# ///
# /// Copy NDArray Pixel Data Start Index to MinX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det4:ConfigXYStart")
{
  field(INPA, "BL99:Det:N1:Det4:NDArrayStart_RBV")
  field(CALC, "A")
  field(OUT, "BL99:Det:N1:Det4:XY:Min0 PP")
  field(FLNK, "BL99:Det:N1:Det4:ConfigXYSize")
}

# ///
# /// Copy NDArray Pixel Data Size to SizeX of ROI plugin
# ///
record(calcout, "BL99:Det:N1:Det4:ConfigXYSize")
{
  field(INPA, "BL99:Det:N1:Det4:NDArrayStart_RBV")
  field(INPB, "BL99:Det:N1:Det4:NDArrayEnd_RBV")
  field(CALC, "(B-A)+1")
  field(OUT, "BL99:Det:N1:Det4:XY:Size0 PP")
}



#####################################################################
# Records to provide scale and offset for auto image max scaling using ROI:0

# ///
# /// The scale factor to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det4:XY:Scale:Scale")
{
   field(VAL, "1")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// The offset to use for auto scaling
# ///
record(longout, "BL99:Det:N1:Det4:XY:Scale:Offset")
{
   field(VAL, "0")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Calculate the image max using the mean intensity from the auto scaling stats plugin
# ///
record(calc, "BL99:Det:N1:Det4:XY:Scale:Result")
{
   field(INPA, "BL99:Det:N1:Det4:XY:ROI:0:MeanValue_RBV CP MS")
   field(INPB, "BL99:Det:N1:Det4:XY:Scale:Scale.VAL CP MS")
   field(INPC, "BL99:Det:N1:Det4:XY:Scale:Offset.VAL CP MS")
   field(CALC, "FLOOR((A*B)+C)")
}

# ///
# /// Default max value for the manual scale slider and image max.
# ///
record(longout, "BL99:Det:N1:Det4:XY:Scale:ManualMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}

# ///
# /// Slide max value for the manual control.
# ///
record(longout, "BL99:Det:N1:Det4:XY:Scale:SlideMax")
{
   field(VAL, "4092")
   field(PINI, "YES")
   info(autosaveFields, "VAL")
   field(ASG, "ALWAYS")
}




#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugin for a single detector for the TOF spectrums. 
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# NELEMENTS - Max size of TOF spectrum
#
#####################################################################


# TOF Initial ROI (to extract the 1-D TOF spectrum)
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:AsynIO")
{
    field(PORT, N1.DET4.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROI.template
# Database for ND ROIs
# Mark Rivers
# April 22, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:AsynIO")
{
    field(PORT, N1.DET4.TOF)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including binning, region start and size                       # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:BinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:BinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:BinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:BinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:BinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_BIN")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:BinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:MinZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_MIN")
   field(LOPR, "1")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:MinZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:SizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:SizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:AutoSizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:AutoSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:AutoSizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:AutoSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:AutoSizeZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_AUTO_SIZE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:AutoSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_AUTO_SIZE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:MaxSizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:ReverseX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ReverseX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:ReverseY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ReverseY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:ReverseZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_REVERSE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ReverseZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_REVERSE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:EnableX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM0_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM0_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:EnableY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM1_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM1_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(bo, "BL99:Det:N1:Det4:TOF:EnableZ")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)DIM2_ENABLE")
   field(VAL,  "1")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)DIM2_ENABLE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the scaling of the data.  Useful when    #
#  binning or converting data types                               # 
###################################################################

record(bo, "BL99:Det:N1:Det4:TOF:EnableScale")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)ENABLE_SCALE")
   field(VAL,  "0")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:EnableScale_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ENABLE_SCALE")
   field(ZNAM, "Disable")
   field(ONAM, "Enable")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:Scale")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)SCALE_VALUE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:Scale_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)SCALE_VALUE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF,0,1)ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det4:TOF:MaxX")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:MaxSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det4:TOF:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det4:TOF:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det4:TOF:MaxX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det4:TOF:MinX.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det4:TOF:SizeX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det4:TOF:MaxY")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:MaxSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det4:TOF:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det4:TOF:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det4:TOF:MaxY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det4:TOF:MinY.HOPR NPP")
    field(OUTB, "BL99:Det:N1:Det4:TOF:SizeY.HOPR NPP")
}



# TOF Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:Array:AsynIO")
{
    field(PORT, N1.DET4.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:Array:AsynIO")
{
    field(PORT, N1.DET4.TOF.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det4:TOF:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "16000")
    field(SCAN, "I/O Intr")
}

# Normal TOF ROIs amd Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET4.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:TOF:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:TOF:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:TOF:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:TOF:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:TOF:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:TOF:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:TOF:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.TOF")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:TOF:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:TOF:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:TOF:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:TOF:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:TOF:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:TOF:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:TOF:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:TOF:ROI:AsynIO")
{
    field(PORT, N1.DET4.TOF.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det4:TOF:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det4:TOF:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det4:TOF:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det4:TOF:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det4:TOF:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:TOF:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:TOF:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:TOF:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:TOF:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:TOF:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:TOF:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.TOF.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for TOF XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:TOF:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:TOF:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}








#####################################################################
#
# areaDetector nED client template file. This is used to automatically
# configure the plugins for the pixel XY array for a single detector.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# DET - Detector number (1-based)
# TOFSIZE - Max size of TOF spectrum
# XSIZE - The X size of the XY plot (required for NDStats.template)
# YSIZE - The Y size of the XY plot (required for NDStats.template)
#
#####################################################################


# Pixel Initial ROI to convert from 1-D to 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)NDARRAY_PORT")
    field(VAL,  "N1")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:AsynIO")
{
    field(PORT, N1.DET4.XY)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#####################################################################
#
# areaDetector nED client template file. This is the template
# for the ADnEDPixelROI plugin. This was based on the original
# ROI plugin template, but has had some things removed and
# things added to deal with 1-D to 2-D conversion.
#
# Matt Pearson
# Oct 14
#
# Macros:
# P,R - base PV name
# PORT - Asyn port name
# ADDR - Asyn address (set to zero)
# TIMEOUT - Asyn timeout
# 
#
#####################################################################

###################################################################
#  These records control the label for the ROI                    #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_NAME")
   info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:Name_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_NAME")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################


record(longout, "BL99:Det:N1:Det4:XY:Min0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM0_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Min0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Min1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM1_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Min1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Min2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM2_MIN")
   field(LOPR, "0")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Min2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM2_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Size0")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM0_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Size0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Size1")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM1_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Size1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Size2")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM2_SIZE")
   field(VAL,  "1000000")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(longin, "BL99:Det:N1:Det4:XY:Size2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM2_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:MaxSize0_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:MaxSize1_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:MaxSize2_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_DIM2_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type of the array data          # 
#  The last entry is "Automatic" meaning preserve the data type   #
#  of the input array.                                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:DataTypeOut")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(VAL,  "8")
   info(autosaveFields, "VAL")
   field(ASG, "BEAMLINE")
}

record(mbbi, "BL99:Det:N1:Det4:XY:DataTypeOut_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY,0,1)PIXELROI_ROI_DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(EIST, "Automatic")
   field(EIVL, "-1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the position    #
#  and size to the maximum for the input array                    #
###################################################################

#record(longin, "BL99:Det:N1:Det4:XY:MaxX")
#{
#    field(INP,  "BL99:Det:N1:Det4:XY:MaxSizeX_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det4:XY:SetXHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det4:XY:SetXHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det4:XY:MaxX NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det4:XY:MinX.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det4:XY:SizeX.HOPR NPP")
#}

#record(longin, "BL99:Det:N1:Det4:XY:MaxY")
#{
#    field(INP,  "BL99:Det:N1:Det4:XY:MaxSizeY_RBV CP")
#    field(FLNK, "BL99:Det:N1:Det4:XY:SetYHOPR.PROC PP")
#}

#record(dfanout, "BL99:Det:N1:Det4:XY:SetYHOPR")
#{
#    field(DOL,  "BL99:Det:N1:Det4:XY:MaxY NPP")
#    field(OMSL, "closed_loop")
#    field(OUTA, "BL99:Det:N1:Det4:XY:MinY.HOPR NPP")
#    field(OUTB, "BL99:Det:N1:Det4:XY:SizeY.HOPR NPP")
#}



# Pixel X/Y Waveform
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:Array:AsynIO")
{
    field(PORT, N1.DET4.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStdArrays.template
# Database for NDStdArrays asyn driver and standard asyn device support
# Mark Rivers
# April 14, 2008

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:Array:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Array:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Array:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:Array:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Array:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Array:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Array:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:Array:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:Array:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:Array:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:Array:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:Array:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:Array:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:Array:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Array:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:Array:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Array:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:Array:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:Array:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Array:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Array:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Array:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Array:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Array:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:Array:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ARR,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:Array:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:Array:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Array:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:Array:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:Array:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:Array:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:Array:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:Array:AsynIO")
{
    field(PORT, N1.DET4.XY.ARR)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  This record is the array waveform data                         #
###################################################################
record(waveform, "BL99:Det:N1:Det4:XY:Array:ArrayData")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.ARR,0,1)STD_ARRAY_DATA")
    field(FTVL, "LONG")
    field(NELM, "163840")
    field(SCAN, "I/O Intr")
}

# ROI and Stats
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:ROI:AsynIO")
{
    field(PORT, N1.DET4.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDROIStat.template
###################################################################
#
# Database template for ROI Stat plugin. This only provides
# the Name records. To add in ROIs use the NDROIStatN.template,
# or alternatively use a single NDROIStat8.template to get up to 8
# ROIs.
# 
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ADDR - The Asyn address
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:ROI:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:ROI:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:ROI:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:ROI:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:ROI:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:ROI:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:ROI:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:ROI:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:ROI:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:ROI:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:ROI:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:ROI:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:ROI:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:ROI:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:ROI:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:ROI:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:ROI:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:ROI:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:ROI:AsynIO")
{
    field(PORT, N1.DET4.XY.ROI)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


# ///
# /// Reset the data for all the ROIs
# ///
record(bo, "BL99:Det:N1:Det4:XY:ROI:ResetAll")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_RESETALL")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det4:XY:ROI:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det4:XY:ROI:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det4:XY:ROI:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det4:XY:ROI:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:0:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:0:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:0:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:0:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:0:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:0:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:0:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:0:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:0:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:0:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:0:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,0,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:1:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:1:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:1:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:1:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:1:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:1:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:1:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:1:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:1:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:1:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:1:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,1,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:2:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:2:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:2:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:2:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:2:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:2:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:2:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:2:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:2:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:2:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:2:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,2,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:3:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:3:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:3:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:3:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:3:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:3:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:3:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:3:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:3:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:3:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:3:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,3,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:4:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:4:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:4:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:4:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:4:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:4:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:4:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:4:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:4:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:4:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:4:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,4,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:5:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:5:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:5:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:5:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:5:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:5:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:5:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:5:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:5:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:5:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:5:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,5,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:6:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:6:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:6:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:6:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:6:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:6:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:6:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:6:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:6:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:6:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:6:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,6,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}
#=================================================================#
# Template file: NDROIStatN.template
###################################################################
#
# Database template for ROI Stat plugin. These are the ROI
# specific records. Multiple instances of this template can be
# loaded, each with a different ADDR (which specifies the ROI).
# Much of this was copied from the original ROI and Stats plugins.
#
# Macros:
# P,R - Base PV name
# PORT - Asyn port name
# ROI - The address to use for this ROI (start at 0, up to maxROIs)
#       This ROI number is appended on to the end of the R macro base PV name.
# TIMEOUT - Asyn port timeout
#
# Matt Pearson
# Nov 2014
#
###################################################################


###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:7:Use")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_USE")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:ROI:7:Use_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_USE")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

###################################################################
#  The name of this ROI                                           #
###################################################################
record(stringout, "BL99:Det:N1:Det4:XY:ROI:7:Name")
{
   field(PINI, "YES")
   field(DTYP, "asynOctetWrite")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_NAME")
   info(autosaveFields, "VAL")
}

###################################################################
#  Only reset the data for this ROI                               #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:ROI:7:Reset")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_RESET")
}

###################################################################
#  These records control the background width                     #
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_BGD_WIDTH")
   field(SCAN, "I/O Intr")
   info(autosaveFields, "VAL")
}

###################################################################
#  These records control the ROI definition                       #
#  including region start and size                                # 
###################################################################

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:MinX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:MinX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:MinY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:MinY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:SizeX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:SizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:SizeY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:SizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:MaxSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM0_MAX_SIZE")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:ROI:7:MaxSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_DIM1_MAX_SIZE")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records contain the statistics for the ROI               #
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:ROI:7:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:7:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:7:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:7:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TOTAL")
   field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:ROI:7:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_NET")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control time series                              #
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:ROI:7:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.ROI,7,1)ROISTAT_TS_TIMESTAMP")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}


# Single Stats Plugin on entire 2-D NDArray
#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:Stat:AsynIO")
{
    field(PORT, N1.DET4.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}

#=================================================================#
# Template file: NDStats.template

#=================================================================#
# Template file: NDPluginBase.template
# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

#=================================================================#
# Template file: NDArrayBase.template
# Database for area detector control using asyn driver and standard asyn device support
# Mark Rivers
# March 9, 2008

###################################################################
#  This record contains the version of ADCore                     #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:ADCoreVersion_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ADCORE_VERSION")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  This record contains the asyn port name of this detector       #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:PortName_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PORT_NAME_SELF")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the array size and data type                 #
###################################################################
# The number of dimensions
record(longin, "BL99:Det:N1:Det4:XY:Stat:NDimensions_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_NDIMENSIONS")
    field(SCAN, "I/O Intr")
}

# The array dimensions waveform record
record(waveform, "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV")
{
    field(DTYP, "asynInt32ArrayIn")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_DIMENSIONS")
    field(FTVL, "LONG")
    field(NELM, "10")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
    field(SCAN, "I/O Intr")
}

# Note, we only extract the first 3 dimensions here, but this
# can easily be extended up to the maximum of 10 dimensions
record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "0")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize0_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize0_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim0SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "1")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize1_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize1_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim1SA")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
}

record(subArray, "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dimensions_RBV NPP NMS")
    field(FTVL, "LONG")
    field(MALM, "10")
    field(NELM, "1")
    field(INDX, "2")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:ArraySize2_RBV")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize2_RBV")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:Dim2SA")
#    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Dim3SA")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:BayerPattern_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)BAYER_PATTERN")
   field(ZRST, "RGGB")
   field(ZRVL, "0")
   field(ONST, "GBRG")
   field(ONVL, "1")
   field(TWST, "GRBG")
   field(TWVL, "2")
   field(THST, "BGGR")
   field(THVL, "3")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySizeZ_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE_Z")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArraySize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_SIZE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the data type                            # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Stat:DataType")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:DataType_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the color mode                           #
#  These choices must agree with NDColorMode_t in NDArray.h       # 
###################################################################

record(mbbo, "BL99:Det:N1:Det4:XY:Stat:ColorMode")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   info(autosaveFields, "VAL")
}

record(mbbi, "BL99:Det:N1:Det4:XY:Stat:ColorMode_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COLOR_MODE")
   field(ZRST, "Mono")
   field(ZRVL, "0")
   field(ONST, "Bayer")
   field(ONVL, "1")
   field(TWST, "RGB1")
   field(TWVL, "2")
   field(THST, "RGB2")
   field(THVL, "3")
   field(FRST, "RGB3")
   field(FRVL, "4")
   field(FVST, "YUV444")
   field(FVVL, "5")
   field(SXST, "YUV422")
   field(SXVL, "6")
   field(SVST, "YUV421")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records are the uniqueId and time stamps of the array     #
###################################################################
record(longin, "BL99:Det:N1:Det4:XY:Stat:UniqueId_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)UNIQUE_ID")
    field(SCAN, "I/O Intr")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:TimeStamp_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TIME_STAMP")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:EpicsTSSec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)EPICS_TS_SEC")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:EpicsTSNsec_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)EPICS_TS_NSEC")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_COUNTER")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# Updated rate calculation to use a smoothing factor w/ guard against negative values
record(calc, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV.LB NPP NMS")   # Previous counter value
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:ArrayCounter_RBV NPP NMS")   # Current counter value
    field(INPC, "1.0")                                # Delta time in seconds
    field(INPD, "BL99:Det:N1:Det4:XY:Stat:ArrayRate_RBV.VAL NPP NMS")  # Previous rate
    field(INPE, "0.0")                 # Smoothing factor
    field(CALC, "(D*E)/C+MAX(0,B-A)*(1-E)/C")
    field(PREC, "2" )
    field(EGU,  "Hz" )
    field(SCAN, "1 second")
}

###################################################################
#  These records control NDArray callacks                         # 
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ArrayCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ArrayCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ARRAY_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(SCAN, "I/O Intr")
}

###################################################################
#  This record is the name of a file defining attributes        # 
###################################################################

record(waveform, "BL99:Det:N1:Det4:XY:Stat:NDAttributesFile")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ND_ATTRIBUTES_FILE")
    field(FTVL, "CHAR")
    field(NELM, "256")
    info(autosaveFields, "VAL")
}

###################################################################
#  Status of NDArrayPool - number of buffers, memory used etc.    # 
###################################################################

record(ai, "BL99:Det:N1:Det4:XY:Stat:PoolMaxMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_MAX_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolMaxBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_MAX_BUFFERS")
   field(SCAN, "Passive")
   field(PINI, "YES")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:PoolUsedMem")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_USED_MEMORY")
   field(PREC, "1")
   field(EGU,  "MB")
   field(SCAN, "1 second")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers")
   info(autosaveFields, "SCAN")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_ALLOC_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)POOL_FREE_BUFFERS")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:PoolUsedBuffers")
}

record(calc, "BL99:Det:N1:Det4:XY:Stat:PoolUsedBuffers")
{
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:PoolAllocBuffers NPP MS")
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:PoolFreeBuffers NPP MS")
    field(CALC, "A-B")
}

###################################################################
#  This record contains the type of plugin                        #
###################################################################

record(stringin, "BL99:Det:N1:Det4:XY:Stat:PluginType_RBV")
{
   field(DTYP, "asynOctetRead")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PLUGIN_TYPE")
   field(VAL,  "Unknown")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "BL99:Det:N1:Det4:XY:Stat:NDArrayPort")
{
    field(PINI, "YES")
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_PORT")
    field(VAL,  "N1.DET4.XY")
    info(autosaveFields, "VAL")
}

record(stringin, "BL99:Det:N1:Det4:XY:Stat:NDArrayPort_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:NDArrayAddress")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_ADDR")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:NDArrayAddress_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:EnableCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MinCallbackTime")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(VAL,  "0.0")
    info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MinCallbackTime_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_CALLBACK_TIME")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:BlockingCallbacks")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(VAL,  "0")
    info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:BlockingCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)BLOCKING_CALLBACKS")
    field(ZNAM, "No")
    field(ONAM, "Yes")
    field(SCAN, "I/O Intr")
}


record(longout, "BL99:Det:N1:Det4:XY:Stat:DroppedArrays")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)DROPPED_ARRAYS")
    field(VAL,  "0")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:DroppedArrays_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)QUEUE_SIZE")
    field(PINI, "YES")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueFreeLow")
}

record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueFreeLow") {
    field(CALC, "A*0.25")
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
    field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueFree.LOW")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIGH")
}

# Set a HIGH warning level for the input queue fill level to 75%
# of the full size of the queue
record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIGH") {
   field(CALC, "A*0.75")
   field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueUse.HIGH")
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIHI")
}

# Set a HIHI level for the input queue fill level to indicate an error
# (MAJOR alarm)  when it fills up to the full size of the queue (frames start dropping)
record(calcout, "BL99:Det:N1:Det4:XY:Stat:QueueUseHIHI") {
   field(CALC, "A*1.0")
   field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
   field(OUT,  "BL99:Det:N1:Det4:XY:Stat:QueueUse.HIHI")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:QueueFree")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)QUEUE_FREE")
    field(LLSV, "MAJOR")
    field(LSV,  "MINOR")
    field(LOLO, "0")
    field(HYST, "1")
    field(SCAN, "I/O Intr")
}

# Display the fill level on the plugins input queue
record(calc, "BL99:Det:N1:Det4:XY:Stat:QueueUse") {
    field(CALC, "A-B")
    field(INPA, "BL99:Det:N1:Det4:XY:Stat:QueueSize")
    field(INPB, "BL99:Det:N1:Det4:XY:Stat:QueueFree CP")
    field(SCAN, "Passive")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(HYST, "1")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"BL99:Det:N1:Det4:XY:Stat:AsynIO")
{
    field(PORT, N1.DET4.XY.STAT)
    field(TIB2,"1")
    info("ADType", "ADPlugin")
}


###################################################################
#  These records contain the basic statistics                     #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ComputeStatistics")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(VAL,  "1")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ComputeStatistics_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_STATISTICS")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:BgdWidth")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)BGD_WIDTH")
   field(VAL,  "1")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:BgdWidth_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)BGD_WIDTH")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MinValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MinValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MaxValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MaxValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MeanValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MEAN_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MeanValue_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MEAN_VALUE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:SigmaValue")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMA_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:Sigma_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMA_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:Total")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)TOTAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:Total_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TOTAL")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:Net")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)NET")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:Net_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)NET")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MinX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_X")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MinX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MinY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_Y")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MinY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MIN_Y")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MaxX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_X")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MaxX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_X")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:MaxY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_Y")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:MaxY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)MAX_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether centroid statistics are computed #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ComputeCentroid")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_CENTROID")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ComputeCentroid_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_CENTROID")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records contain the centroid statistics                  #
###################################################################
record(ao, "BL99:Det:N1:Det4:XY:Stat:CentroidThreshold")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "1")
    info(autosaveFields, "VAL")
}
record(ai, "BL99:Det:N1:Det4:XY:Stat:CentroidThreshold_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROID_THRESHOLD")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:CentroidX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROIDX_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:CentroidX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROIDX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:CentroidY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROIDY_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:CentroidY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)CENTROIDY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:SigmaX")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAX_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:SigmaX_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAX_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:SigmaY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAY_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:SigmaY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAY_VALUE")
   field(PREC, "1")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:SigmaXY")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAXY_VALUE")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:SigmaXY_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)SIGMAXY_VALUE")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control time series                              #
###################################################################
record(mbbo, "BL99:Det:N1:Det4:XY:Stat:TSControl")
{
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)TS_CONTROL")
   field(ZRVL, "0")
   field(ZRST, "Erase/Start")
   field(ONVL, "1")
   field(ONST, "Start")
   field(TWVL, "2")
   field(TWST, "Stop")
   field(THVL, "3")
   field(THST, "Read") 
}

# This record periodically pokes the TSControl record with 3 to read the time series
# but only when TSAcquiring = Acquiring
record(longout, "BL99:Det:N1:Det4:XY:Stat:TSRead")
{
   field(SDIS, "BL99:Det:N1:Det4:XY:Stat:TSAcquiring NPP NMS")
   field(DISV, "0")
   field(OUT,  "BL99:Det:N1:Det4:XY:Stat:TSControl PP MS")
   field(VAL,  "3")
   field(SCAN, "1 second")
   info(autosaveFields, "SCAN")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:TSNumPoints")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)TS_NUM_POINTS")
   field(VAL,  "1024")
   field(DRVH, "1024")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:TSCurrentPoint")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_CURRENT_POINT")
   field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:TSAcquiring")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_ACQUIRING")
   field(ZNAM, "Done")
   field(ONAM, "Acquiring")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMinValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MIN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMinX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MIN_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMinY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MIN_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMaxValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMaxX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MAX_X")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMaxY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MAX_Y")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSMeanValue")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_MEAN_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSSigma")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_SIGMA_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSTotal")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_TOTAL")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSNet")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_NET")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSCentroidX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_CENTROIDX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSCentroidY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_CENTROIDY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSSigmaX")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_SIGMAX_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSSigmaY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_SIGMAY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSSigmaXY")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_SIGMAXY_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:TSTimestamp")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)TS_TIMESTAMP_VALUE")
   field(NELM, "1024")
   field(FTVL, "DOUBLE")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control profiles                                 #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ComputeProfiles")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_PROFILES")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ComputeProfiles_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_PROFILES")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ProfileSizeX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:ProfileSizeY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:CursorX")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)CURSOR_X")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:CursorX_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)CURSOR_X")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:CursorY")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)CURSOR_Y")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:CursorY_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)CURSOR_Y")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileAverageX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_AVERAGE_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileAverageY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_AVERAGE_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileThresholdX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_THRESHOLD_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileThresholdY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_THRESHOLD_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileCentroidX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_CENTROID_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileCentroidY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_CENTROID_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileCursorX_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_CURSOR_X")
   field(FTVL, "DOUBLE")
   field(NELM, "160")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:ProfileCursorY_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)PROFILE_CURSOR_Y")
   field(FTVL, "DOUBLE")
   field(NELM, "32")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These are used to define the histogram                         #
###################################################################
record(bo, "BL99:Det:N1:Det4:XY:Stat:ComputeHistogram")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(VAL,  "0")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   info(autosaveFields, "VAL")
}

record(bi, "BL99:Det:N1:Det4:XY:Stat:ComputeHistogram_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)COMPUTE_HISTOGRAM")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(ZSV,  "NO_ALARM")
   field(OSV,  "MINOR")
   field(SCAN, "I/O Intr")
}

record(longout, "BL99:Det:N1:Det4:XY:Stat:HistSize")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_SIZE")
   field(VAL,  "256")
   info(autosaveFields, "VAL")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:HistSize_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_SIZE")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:HistMin")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_MIN")
   field(VAL,  "0")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:HistMin_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_MIN")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:HistMax")
{
   field(PINI, "YES")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_MAX")
   field(VAL,  "255")
   info(autosaveFields, "VAL")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:HistMax_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_MAX")
   field(SCAN, "I/O Intr")
}

record(ao, "BL99:Det:N1:Det4:XY:Stat:HistEntropy")
{
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_ENTROPY")
}

record(ai, "BL99:Det:N1:Det4:XY:Stat:HistEntropy_RBV")
{
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_ENTROPY")
   field(PREC, "3")
   field(SCAN, "I/O Intr")
}

record(waveform, "BL99:Det:N1:Det4:XY:Stat:Histogram_RBV")
{
   field(DTYP, "asynFloat64ArrayIn")
   field(INP,  "@asyn(N1.DET4.XY.STAT,0,1)HIST_ARRAY")
   field(FTVL, "DOUBLE")
   field(NELM, "163840")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records set the HOPR and LOPR values for the cursor      #
#  and size to the maximum for the input array                    #
###################################################################

record(longin, "BL99:Det:N1:Det4:XY:Stat:MaxSizeX")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:ProfileSizeX_RBV CP")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:SetXHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det4:XY:Stat:SetXHOPR")
{
    field(DOL,  "BL99:Det:N1:Det4:XY:Stat:MaxSizeX NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det4:XY:Stat:CursorX.HOPR NPP")
}

record(longin, "BL99:Det:N1:Det4:XY:Stat:MaxSizeY")
{
    field(INP,  "BL99:Det:N1:Det4:XY:Stat:ProfileSizeY_RBV CP")
    field(FLNK, "BL99:Det:N1:Det4:XY:Stat:SetYHOPR.PROC PP")
}

record(dfanout, "BL99:Det:N1:Det4:XY:Stat:SetYHOPR")
{
    field(DOL,  "BL99:Det:N1:Det4:XY:Stat:MaxSizeY NPP")
    field(OMSL, "closed_loop")
    field(OUTA, "BL99:Det:N1:Det4:XY:Stat:CursorY.HOPR NPP")
}

###################################################################
#  These records reset the statistics                             #
###################################################################
record(sseq, "BL99:Det:N1:Det4:XY:Stat:Reset")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det4:XY:Stat:MinValue PP MS")    
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det4:XY:Stat:MaxValue PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det4:XY:Stat:MaxValue PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det4:XY:Stat:MeanValue PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det4:XY:Stat:SigmaValue PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det4:XY:Stat:Total PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det4:XY:Stat:Net PP MS")    
   field(DOL8, "0")
   field(DLY8, "0")
   field(LNK8, "BL99:Det:N1:Det4:XY:Stat:MinX PP MS")    
   field(DOL9, "0")
   field(DLY9, "0")
   field(LNK9, "BL99:Det:N1:Det4:XY:Stat:MinY PP MS")    
   field(DOLA, "0")
   field(DLYA, "0")
   field(LNKA, "BL99:Det:N1:Det4:XY:Stat:MaxX PP MS")    
   field(FLNK, "BL99:Det:N1:Det4:XY:Stat:Reset1")   
}

record(sseq, "BL99:Det:N1:Det4:XY:Stat:Reset1")
{
   field(DOL1, "0")
   field(DLY1, "0")
   field(LNK1, "BL99:Det:N1:Det4:XY:Stat:MaxY PP MS")
   field(DOL2, "0")
   field(DLY2, "0")
   field(LNK2, "BL99:Det:N1:Det4:XY:Stat:CentroidX PP MS")    
   field(DOL3, "0")
   field(DLY3, "0")
   field(LNK3, "BL99:Det:N1:Det4:XY:Stat:CentroidY PP MS")    
   field(DOL4, "0")
   field(DLY4, "0")
   field(LNK4, "BL99:Det:N1:Det4:XY:Stat:SigmaX PP MS")    
   field(DOL5, "0")
   field(DLY5, "0")
   field(LNK5, "BL99:Det:N1:Det4:XY:Stat:SigmaY PP MS")    
   field(DOL6, "0")
   field(DLY6, "0")
   field(LNK6, "BL99:Det:N1:Det4:XY:Stat:SigmaXY PP MS")    
   field(DOL7, "0")
   field(DLY7, "0")
   field(LNK7, "BL99:Det:N1:Det4:XY:Stat:HistEntropy PP MS")    
}





#####################################################################
# Put ROI0 to ROI4 into ASG=ALWAYS group for pixel XY plot.


#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:0:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:0:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:1:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:1:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:2:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:2:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:3:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:3:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:4:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:4:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:5:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:5:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:6:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:6:SizeY")
{
  field(ASG, "ALWAYS")
}



#####################################################################
# Put an ROI into ASG=ALWAYS group.

record(bo, "BL99:Det:N1:Det4:XY:ROI:7:Use")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:MinX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:MinY")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:SizeX")
{
  field(ASG, "ALWAYS")
}

record(longout, "BL99:Det:N1:Det4:XY:ROI:7:SizeY")
{
  field(ASG, "ALWAYS")
}







##########################################################################


# ///
# /// Records to calculate what the overall Status PV should be
# ///
record(calcout, "BL99:Det:N1:StatusCalc")
{
   field(DESC, "Calc ADnED Status")
   field(PINI, "YES")
   field(VAL, "0")
   field(INPA, "BL99:Det:N1:DetectorState_RBV CP MS")
   field(INPB, "BL99:Det:N1:BadTimeStamp_RBV CP MS")
   field(INPC, "BL99:Det:N1:SeqIDNumMissing_RBV CP MS")
   field(INPD, "BL99:Det:N1:AllocSpaceStatus_RBV CP MS")
   field(CALC, "(A>1)||(B!=0)||(C!=0)||(D>1)?1:0")
   field(OOPT, "Every Time")
   field(DOPT, "Use CALC")
   field(OUT, "BL99:Det:N1:Status.VAL PP")
}

# ///
# /// 0 = Ok (No error and we are either Idle or Acquiring).
# /// 1 = Error (Combined Error PV is 1)
# ///
record(bi, "BL99:Det:N1:Status")
{
   field(DESC, "Motor Status")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

### the leak PV

# ///
# /// This will be non-zero if any missing V4 packets are detected on channel 0. 
# /// This record will be updated with the latest missing sequence ID.
# ///
record(longin, "BL99:Det:N1:SeqID0Missing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_ID_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is the number of missing V4 packets on channel 0, if any have been detected.
# ///
record(longin, "BL99:Det:N1:SeqID0NumMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_SEQ_ID_NUM_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is a flag to indicate I detected an out of order packet (with backwards timestamp) 
# /// on channel 0.
# ///
record(bi, "BL99:Det:N1:BadTimeStamp0_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,0,5)ADNED_BAD_TIMESTAMP")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(ZSV, "NO_ALARM")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}


# ///
# /// This will be non-zero if any missing V4 packets are detected on channel 1. 
# /// This record will be updated with the latest missing sequence ID.
# ///
record(longin, "BL99:Det:N1:SeqID1Missing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_SEQ_ID_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is the number of missing V4 packets on channel 1, if any have been detected.
# ///
record(longin, "BL99:Det:N1:SeqID1NumMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_SEQ_ID_NUM_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is a flag to indicate I detected an out of order packet (with backwards timestamp) 
# /// on channel 1.
# ///
record(bi, "BL99:Det:N1:BadTimeStamp1_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,1,5)ADNED_BAD_TIMESTAMP")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(ZSV, "NO_ALARM")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This will be non-zero if any missing V4 packets are detected on channel 2. 
# /// This record will be updated with the latest missing sequence ID.
# ///
record(longin, "BL99:Det:N1:SeqID2Missing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_SEQ_ID_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is the number of missing V4 packets on channel 2, if any have been detected.
# ///
record(longin, "BL99:Det:N1:SeqID2NumMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_SEQ_ID_NUM_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is a flag to indicate I detected an out of order packet (with backwards timestamp) 
# /// on channel 2.
# ///
record(bi, "BL99:Det:N1:BadTimeStamp2_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,2,5)ADNED_BAD_TIMESTAMP")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(ZSV, "NO_ALARM")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This will be non-zero if any missing V4 packets are detected on channel 3. 
# /// This record will be updated with the latest missing sequence ID.
# ///
record(longin, "BL99:Det:N1:SeqID3Missing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_SEQ_ID_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is the number of missing V4 packets on channel 3, if any have been detected.
# ///
record(longin, "BL99:Det:N1:SeqID3NumMissing_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_SEQ_ID_NUM_MISSING")
   field(SCAN, "I/O Intr")
   field(LOLO, "-1")
   field(HIHI, "1")
   field(LLSV, "MAJOR")
   field(HHSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}

# ///
# /// This is a flag to indicate I detected an out of order packet (with backwards timestamp) 
# /// on channel 3.
# ///
record(bi, "BL99:Det:N1:BadTimeStamp3_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(N1,3,5)ADNED_BAD_TIMESTAMP")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Ok")
   field(ONAM, "Error")
   field(ZSV, "NO_ALARM")
   field(OSV, "MAJOR")
   info(archive, "Monitor, 00:00:01, VAL")
}


record(bi, "BL99:Det:N1:Det1:TOF:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.TOF.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}


record(bi, "BL99:Det:N1:Det2:TOF:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.TOF.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det3:TOF:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.TOF.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det4:TOF:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.TOF.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det1:XY:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET1.XY.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

record(bi, "BL99:Det:N1:Det2:XY:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET2.XY.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}


record(bi, "BL99:Det:N1:Det3:XY:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET3.XY.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}


record(bi, "BL99:Det:N1:Det4:XY:Mask:EnableCallbacks_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(N1.DET4.XY.MASK,0,1)ENABLE_CALLBACKS")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MINOR")
    field(SCAN, "I/O Intr")
}

